<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
</head>
<body>
<h1 id="anonymous-proof-of-possession-in-the-context-of-diplomata-record-ledger-uc3">Anonymous Proof of Possession in the context of Diplomata Record Ledger (UC3)</h1>
<h2 id="introduction">Introduction</h2>
<p><em>Diplomata</em> is a proposed system for proving and verifying title possession in a privacy-preserving fashion. It involves three kinds of interacting network entities: <em>Holders</em> of qualifications, which they can present to interested parties, <em>Issuers</em> capable of issuing qualifications to holders, and <em>Verifiers</em> able to verify the holders' claims of possessing a title. Awarding of titles, requests of certification, acknowledgments of certification etc. are all recorded in the form of transaction in a blockchain ledger, in order for the involved entities to be held publicly accountable for their actions. Requirements like <em>access control</em> on behalf of the holders, resistance to <em>no honesty</em> and <em>auditability</em> by external observers should also be satisfied.</p>
<p>A <em>ZK-Decryptor Protocol</em> (<em>ZKD</em>) has already been proposed on top of an El-Gamal cryptosystem, that allows holders to (indirectly) prove possession of titles to verifiers. However, the Issuer of the title is heavily involved in the process. Except for an initial certification request and the private communication of the accompanying commitment to the Verifier, the rest of communication takes place between Issuer and Verifier: it is the <em>Issuer</em> who actually commits and generates the proof of award that will be finally verified. More importantly, verification of proof presupposes that the (content of the) title will be decrypted by the Verifier and thus <em>disclosed</em> to them, i.e., &quot;zero-knowledge&quot; does not refer to the qualification' content. Since the title contains as such reference to the Holder's identity, this entails <em>non</em>-anonymity for the Holder.</p>
<p>Purpose of this text is to propose an alternative to the <em>ZKD</em> protocol for the case where the Holder's anonymity is desired and the (content of the) title should not be revealed. This pertains to the following meritocratic scenario. Holder and Verifier meet anonymously online with the requirement that their communication channel remains private and their identities unrevealed. In particular, the Holder wishes to prove possession of a title <span class="math inline">\(t\)</span></p>
<ol style="list-style-type: decimal">
<li>without ever revealing their identity, since the communication must remain anonymous</li>
<li>without disclosing any info about <span class="math inline">\(t\)</span>, except for the fact that it exists among their acquired qualifications</li>
<li>in one single communication step</li>
<li>without involvement of anybody else in that step (say, the Issuer of <span class="math inline">\(t\)</span>), since the communication must remain private</li>
</ol>
<p>The proposed protocol will be referred to as <em>Anonymous Proof of Possession Protocol</em> (<em>APP</em>). Proof of possession should be thought of as proof of <em>inclusion</em> in a set of recordedly awarded titles (possibly of a special kind) strongly correlated to the prover's (unrevealed) identity. In doing so, we will employ the <em>zk-SNARK</em> cryptographic scheme combined with a commitment mechanism. In particular, proof of possession will be a zk-SNARK proof.</p>
<p>Such a construction will partly resemble the <em>ZeroCash</em> anonymous payment scheme, with each title interpreted as 1 BTC (bitcoin) and the holders' commitments recorded in the ledger. There are, however, two major differences:</p>
<ol style="list-style-type: decimal">
<li><p>No &quot;Direct Anonymous Payment&quot; method is here facilitated, that is, transfer of titles(=coins) from holder to holder is <em>not</em> anyhow taken into account. This allows to stay away from the intricacies of the key-address machinery surrounding commitments in the ZeroCash cryptographic flow.</p></li>
<li><p>Except for the Prover(=Holder) and Verifier, a third party, the <em>Issuer</em>, is responsible for recording the Holder's commitment: contrary to the commitment to a coin's serial number, the Holder's commitment to a title's serial number is appended to the ledger not by the Holder, but by the Issuer. Note, however, that this involvement does <em>not</em> violate requirement 4: it takes place <em>prior to</em> generation and transmission of any proof of possession for <span class="math inline">\(t\)</span>. More specifically, <span class="math inline">\(I\)</span> 's role is limited to the preparation of context for these proofs, without ever involving to any of them.</p></li>
</ol>
<p>It should be finally stressed that the here proposed <em>APP</em> protocol is not intended to replace <em>ZKD</em> and should not be considered as an improvement of it. It is rather complementary to it in the context of a <em>Diplomata</em> application, whenever the utmost degree of anonymity is desired. In fact, <em>APP</em> has some practical drawbacks compared to <em>ZKD</em>:</p>
<ol style="list-style-type: decimal">
<li>Being due to non-interactiveness, anonymity of the Holder is at the cost of the Verifier's ability to check for certificate revocation. That is, if certificate revocation is supported by the system, then the proposed proof of possession is only equivalent to a <em>proof of acquisition</em>. This is because approval of certification takes place upon issuance of the title by the Issuer and a subsequent revocation would need the latter's involvement in order to be known. If the Verifier wants to verify that a title is <em>still</em> possessed by the Holder, they would need to proceed to a second stage and run some additional, possibly non-anonymous proof-verify session, where the Issuer intermedieates in order to convey info about possible revocation.</li>
<li>Being a zk-SNARK protocol, <em>APP</em>'s setup presupposes a public ceremony for destroying the randomness used in the Common Reference String (CRS) generation.</li>
</ol>
<p>With these limitation in mind, we proceed to the exact description of the protocol.</p>
<h2 id="the-anonymous-proof-of-possession-app-protocol">The Anonymous Proof of Possession (APP) Protocol</h2>
<p>As usually, an append-only public ledger (say, blockchain) is available, where all actions of network entities are recorded in the form of serial number. Serial numbers can be randomly selected but unique for each action; they are accompanied by a tag, indicating the kind of action to record in the ledger. Only a set of predefined tags is acceptable; furthermore, special rules might determine which tags are allowed to be used by the various network entities. For example, only issuers are allowed to append serial numbers with the tag corresponding to title issuance.</p>
<h3 id="preliminary-discussion">Preliminary discussion</h3>
<p>Let <span class="math inline">\(t\)</span> be a title issued by <span class="math inline">\(I\)</span> to a holder <span class="math inline">\(H\)</span>. The action of issuance is assigned by <span class="math inline">\(I\)</span> a unique serial number <span class="math inline">\(s\)</span>, which <span class="math inline">\(I\)</span> possibly records in the ledger. Note that this mere record conveys no info about either <span class="math inline">\(t\)</span> or <span class="math inline">\(H\)</span>, beyond the fact that some title has been issued at some point of history. Consequently, only <span class="math inline">\(I\)</span> can certify that <span class="math inline">\(s\)</span> relates to the particular title acquired by <span class="math inline">\(H\)</span>.</p>
<p>This observation has major effect on the communication between <span class="math inline">\(H\)</span> and a verifier <span class="math inline">\(V\)</span>, to whom <span class="math inline">\(H\)</span> wants to prove knowledge of <span class="math inline">\(t\)</span>: using <span class="math inline">\(s\)</span> alone in order to verify possession of <span class="math inline">\(t\)</span> would necessarily need to involve <span class="math inline">\(I\)</span> and communicate <span class="math inline">\(s\)</span> to them, violating the requirement of privacy. More importantly, having assigned <span class="math inline">\(s\)</span> to the fact of issuance, <span class="math inline">\(I\)</span> can infer from <span class="math inline">\(s\)</span> both <span class="math inline">\(H\)</span>'s identity and <span class="math inline">\(t\)</span>'s content. Clearly, in order for identity and content to remain secret, <span class="math inline">\(s\)</span> can not be alone used in the private communication between <span class="math inline">\(H\)</span> and <span class="math inline">\(V\)</span>. If <span class="math inline">\(H\)</span> wants to be able to prove possession without having <span class="math inline">\(V\)</span> appeal to <span class="math inline">\(I\)</span>, <span class="math inline">\(s\)</span> must be communicated to <span class="math inline">\(V\)</span> along with some additional quantity.</p>
<p>Due to the binding property, a natural choice is to use a commitment. Assume that a statistically-secure commitment mechanism <span class="math inline">\(Comm\)</span> is available. Whenever <span class="math inline">\(H\)</span> wants to prove possession of <span class="math inline">\(t\)</span> to a verifier <span class="math inline">\(V\)</span>, the holder could, say, send a commitment <span class="math inline">\(c=Comm(r, s)\)</span> along with <span class="math inline">\(s\)</span>, so that <span class="math inline">\(V\)</span> could later open the commitment with <span class="math inline">\(r\)</span> and verify that its content is <span class="math inline">\(s\)</span>. This scenario is severely flawed, since binding of <span class="math inline">\(H\)</span> to <span class="math inline">\(s\)</span> does no way guarantee possession of <span class="math inline">\(t\)</span>: <span class="math inline">\(H\)</span> can commit to arbitrary serial numbers; even if <span class="math inline">\(V\)</span> audits the ledger to check that s appears in it, <span class="math inline">\(H\)</span> could still have committed to the serial number of a title they don't possess. We thus need a further binding of <span class="math inline">\(s\)</span> to <span class="math inline">\(t\)</span>, i.e, a certification that the serial number of <span class="math inline">\(t\)</span>'s issuance is <span class="math inline">\(s\)</span>. We know only <span class="math inline">\(I\)</span> can give this certification, so any commitment used by <span class="math inline">\(H\)</span> must be beforehand publicly approved by <span class="math inline">\(I\)</span>.</p>
<p>We let <span class="math inline">\(I\)</span> approve and subsequently record <span class="math inline">\(c\)</span> in the ledger. <span class="math inline">\(H\)</span> can now point to the public record <span class="math inline">\(c\)</span> and send <span class="math inline">\(r\)</span> to <span class="math inline">\(V\)</span>, who can then unlock <span class="math inline">\(c\)</span> with <span class="math inline">\(r\)</span> and verify its content. However, consumption of <span class="math inline">\(r\)</span> by the verifier means that a new commitment must be generated by <span class="math inline">\(H\)</span> for each proof-verify session (otherwise a dishonest verifier could leak r to a malicious holder, who could then successfully prove possession of <span class="math inline">\(t\)</span> by simply pointing to <span class="math inline">\(c\)</span> on the public ledger). Consequently, <span class="math inline">\(H\)</span> must repeatedly appeal to <span class="math inline">\(I\)</span> for approval.</p>
<p>We can employ proof-of-knowledge for the purpose of generating only once a commitment and thus minimizing interaction with <span class="math inline">\(I\)</span>. Instead of communicating <span class="math inline">\(r\)</span> to <span class="math inline">\(V\)</span>, the holder could equivalently prove knowledge of the particular trapdoor <span class="math inline">\(r\)</span> which unlocks the <span class="math inline">\(c\)</span> public record. Indeed:</p>
<ol style="list-style-type: decimal">
<li><p>Since this record has been approved by <span class="math inline">\(I\)</span>, verifying the proof is equivalent to verifying possession of <span class="math inline">\(t\)</span> on behalf of <span class="math inline">\(H\)</span>.</p></li>
<li><p>Since <span class="math inline">\(r\)</span> remains secret, <span class="math inline">\(c\)</span> may be uniformly reused by <span class="math inline">\(H\)</span> in all proof-verify sessions concerning <span class="math inline">\(t\)</span>.</p></li>
</ol>
<p>What can this proof-of-knowledge mechanism be? In fact, the holder does not even have to point to the <span class="math inline">\(c\)</span> public record: given <span class="math inline">\(s\)</span>, and assuming that approved commitments are recorded with a tag COMM indicating their nature, <span class="math inline">\(H\)</span> needs only prove the following claim:</p>
<p><span class="math display">\[\text{&quot;I know } r \text{ such that } Comm(r, s) \text{ appears in the public ledger with tag COMM&quot; }\]</span></p>
<p>This statement is obviously NP-complete. Consequently, it can be produced as a zk-SNARK proof upon the predicate</p>
<p><span class="math display">\[F(r, s) = Comm(r, s) \text{ appears in the public ledger with tag COMM }\]</span></p>
<p>In other words, the desired proof-of-knowledge mechanism can be a zk-SNARK cryptosystem with public predicate <span class="math inline">\(F\)</span>. The trapdoor <span class="math inline">\(r\)</span> serves as the secret witness to the serial number <span class="math inline">\(s\)</span>, which serves in turn as the public instance of the predicate.</p>
<p>Till now we have only adjusted part of the <em>ZeroCash</em> protocol to the <em>Diplomata</em> context, where awarded titles are interpreted as 1 BTC. In ZeroCash, a holder's commitment to a particular bitcoin collection is approved and recorded by means of an escrow (e.g., when physical money is exchanged for electronic cash). In our protocol, this is equivalent to the certification on behalf of <span class="math inline">\(I\)</span> that <span class="math inline">\(c = Comm(r, s)\)</span> is a commitment to <span class="math inline">\(s\)</span>: in order to record <span class="math inline">\(c\)</span> in the public ledger, the issuer must first ensure that the holder has indeed committed to <span class="math inline">\(s\)</span> and not any arbitrary value. On the other hand, the trapdoor <span class="math inline">\(r\)</span> must remain eternally secret. In particular, <span class="math inline">\(H\)</span> cannot communicate <span class="math inline">\(r\)</span> to <span class="math inline">\(I\)</span> in order for the latter to unlock the commitment and certify its content: a dishonest <span class="math inline">\(I\)</span> could leak r to a malicious holder, who would then successfully prove possession of <span class="math inline">\(t\)</span> by simply generating a proof on top of the zk-SNARK infrastructure. We have to solve the following problem: how can the issuer certify commitment to the correct serial number without knowing the secret trapdoor?</p>
<p>To do so, we will take advantage of the commitment's internal mechanism. The scheme particularly suited for our purpose is the <em>Pedersen commitment scheme</em>, as will be explained in the following section.</p>
<h4 id="certification-mechanism">Certification mechanism</h4>
<p>Let <span class="math inline">\(p\)</span> be a large prime, <span class="math inline">\(g\)</span> a generator of the group of quadratic residues in <span class="math inline">\(\mathbb{Z}_p^\star\)</span> and <span class="math inline">\(h\)</span> a randomly chosen residue. Fixing these public parameters, the <em>Pedersen commitment scheme</em> is defined as</p>
<p><span class="math display">\[Comm(r, s) = g^r h^s\]</span></p>
<p>(involved operations taken <span class="math inline">\(mod\)</span> <span class="math inline">\(p\)</span>). Security of the scheme (the hiding and binding properties) depends on further assumptions upon <span class="math inline">\(p\)</span> and <span class="math inline">\(g\)</span> to be stipulated when needed. We are here interested in the following key observation: Let <span class="math inline">\(c = Comm(r, s)\)</span> be the Pedersen commitment of <em>A</em> to a secret <span class="math inline">\(s\)</span>, which is known to both <em>A</em> and <em>B</em>. If <em>A</em> sends <span class="math inline">\(g^r\)</span> and <span class="math inline">\(c\)</span> to <em>B</em>, then</p>
<ol style="list-style-type: decimal">
<li><em>B</em> can check whether <span class="math inline">\(c\)</span> is a commitment to <span class="math inline">\(s\)</span> without knowing the trapdoor <span class="math inline">\(r\)</span></li>
<li><em>B</em> cannot infer the value of <em>r</em></li>
</ol>
<p>Indeed, knowing already <span class="math inline">\(s\)</span>, B can compute <span class="math inline">\(h^s\)</span> and check whether <span class="math inline">\(c\)</span> is equal to <span class="math inline">\(g^r h^s\)</span>. If <em>A</em> had committed to any <span class="math inline">\(s^\prime \neq s\)</span>, i.e., <span class="math inline">\(c = g^r h^{s&#39;}\)</span>, then, in order to deceive <em>B</em>, <em>A</em> would need to fabricate <span class="math inline">\(r^\prime\)</span> such that <span class="math inline">\(g^r h^{s&#39;} = g^{r&#39;} h^s\)</span> or, equivalently, solve</p>
<p><span class="math display">\[r^\prime = \log g^r h^{s^\prime-s}\]</span></p>
<p>which is computationally infeasible in view of discrete logarithm hardness. Based on the same hardness assumption, <em>B</em> cannot infer <em>r</em> from either <span class="math inline">\(g^r\)</span> or <span class="math inline">\(h^s\)</span> or their combinations.</p>
<p>The above observation applies in the <em>Diplomata</em> context by fixing the Pedersen schema as the system's commitment mechanism. Let a holder <span class="math inline">\(H\)</span> and an issuer <span class="math inline">\(I\)</span> have the roles of <em>A</em> resp. <em>B</em>, <span class="math inline">\(s\)</span> be the serial number of a title <span class="math inline">\(t\)</span> issued by <span class="math inline">\(I\)</span> to <span class="math inline">\(H\)</span> and <span class="math inline">\(c\)</span> the holder's commitment to that number. In order to repeatedly use <span class="math inline">\(c\)</span> as certificate in future proof-verify sessions, the holder requests from <span class="math inline">\(I\)</span> to approve their commitment and append it to the public ledger. More accurately, after committing with a randomly chosen trapdoor <span class="math inline">\(r\)</span>, <span class="math inline">\(H\)</span> sends <span class="math inline">\(s\)</span>, <span class="math inline">\(g^r\)</span> and <span class="math inline">\(c\)</span> to <span class="math inline">\(I\)</span> with the request to certify <span class="math inline">\(c\)</span> as commitment to <span class="math inline">\(s\)</span> and subsequently append it to the ledger. <span class="math inline">\(I\)</span> first looks in their database of awarded titles to see if <span class="math inline">\(s\)</span> corresponds indeed to any of them. If yes, <span class="math inline">\(I\)</span> proceeds to certification of <span class="math inline">\(c\)</span> by means of <span class="math inline">\(g^r\)</span>. In case of success, <span class="math inline">\(I\)</span> appends <span class="math inline">\(c\)</span> to the ledger; otherwise the holder's request is rejected. The trapdoor remains unrevealed to the issuer as should.</p>
<h3 id="formal-description">Formal description</h3>
<h4 id="setup">Setup</h4>
<p>Let <em>L</em> denote the public ledger. Among possibly others, we define a tag</p>
<p style="text-align: center;">
COMM,
</p>
<p>indicating a commitment to a title-issuance serial number, and specify that <em>only Issuers have the right to append records with this tag to the ledger</em>.</p>
<h5 id="commitment-mechanism">Commitment mechanism</h5>
<p>We fix a sufficiently high security parameter <span class="math inline">\(n\)</span> and randomly choose <span class="math inline">\(p = 2q + 1\)</span> to be a strong <span class="math inline">\((n + 1)\)</span>-prime (i.e., such that <span class="math inline">\(q\)</span> is prime). Denoting by <span class="math inline">\(Q\subset\mathbb{Z}_p^\star\)</span> the group of quadratic residues, we randomly fix a generator <span class="math inline">\(g\)</span> of <span class="math inline">\(Q\)</span> and a residue <span class="math inline">\(h \in Q\)</span>. We denote by</p>
<p><span class="math display">\[\mathbb{Z}_p^\star\times\mathbb{Z}_p\ni(r, s) \mapsto Comm(r, s) = g^r h^s\]</span></p>
<p>the Pedersen function over the pair <span class="math inline">\((g, h)\)</span>. Under the above assumptions, discrete log hardness becomes plausible and <span class="math inline">\(Comm\)</span> may be considered as a statistically-secure commitment mechanism. We specify that <em>serial numbers assigned by Issuers to title issuance be contained in</em> <span class="math inline">\(\mathbb{Z}_p\)</span>.</p>
<h5 id="zk-snark-infrastructure">zk-SNARK infrastructure</h5>
<p>We consider the predicate</p>
<p><span class="math display">\[F(r, s) = Comm(r, s) \text{ appears in } L \text{ with tag COMM }\]</span></p>
<p>Both lookup in <span class="math inline">\(L\)</span> and evaluation of <span class="math inline">\(Comm\)</span> have polynomial time complexity. Consequently, for any <span class="math inline">\(s\)</span>, the statement</p>
<p><span class="math display">\[\text{I know } r \text{ such that } F(r, s) = 1\]</span></p>
<p>is NP-complete with respect to <span class="math inline">\(r\)</span>. This allows to use <span class="math inline">\(F\)</span> as the public predicate of a zk-SNARK cryptosystem, where <span class="math inline">\(r\)</span> is thought of as the private witness to the public instance <span class="math inline">\(s\)</span>. More accurately, feeding <span class="math inline">\(F\)</span> to a CRS-generator, we denote by</p>
<p style="text-align: center;">
CRS = <span class="math inline">\((pk, vk)\)</span>
</p>
<p>the pair of proving and verifying keys of the induced zk-SNARK cryptosystem. We will denote by</p>
<p><span class="math display">\[(\mathit{pk}, s, r) \mapsto \pi = Prover(\mathit{pk}, s, r),\]</span> <span class="math display">\[(vk, s, \pi) \mapsto Verifier(vk, s, \pi) \in {0, 1}\]</span></p>
<p>the Prover and Verifier functionalities of the zk-SNARK cryptosystem respectively. We specify that <em>every Holder can internally run a Prover and Verifiers coincide with Verifiers of the</em> zk-SNARK <em>cryptosystem</em>.</p>
<!-- ...

Let $t$ be a title held by a Holder $H$ and issued by Issuer $I$. In order for
$H$ to be able to anonymously prove possession of $t$ at any
future moment, the following Steps 1-4 must take place (once per t) -->
<h4 id="cryptographic-flow">Cryptographic flow</h4>
<h5 id="certification-phase-once-per-title">Certification phase (once per title)</h5>
<!-- 1. Upon issuance of $t$, $I$ uniquely assigns to it a serial number $s$. (For
transparency or history reasons, $I$ might record $s$ in the public ledger,
but this is irrelevant to what follows.)

2. $I$ privately communicates $s$ to $H$.

3. $H$ requests from $I$ to record their commitment to $s$ in the public ledger.
In particular, $H$ chooses a secret trapdoor $r$ and computes a commitment
$$c = Comm(r, s)$$
which they privately communicate to $I$. This commitment is generated
once per $t$ and will be used in any subsequent prove-verify session concerning
this title.

4. Being the issuer of $t$, $I$ verifies and approves $H$'s commitment to $s$,
which they subsequently append to the public ledger. Note that only the issuer
$I$ of $t$ should be able to approve $c$ and record it in the ledger. In the
cryptocurrency terminology, approval on behalf of $I$ is equivalent to a
guaratee that $H$ has spent 1 BTC to an escrow pool. $H$ can anytime
check whether $c$ has indeed been recorded, since the ledger is public. -->
<h5 id="proof-verify-session">Proof-verify session</h5>
<h3 id="performance-and-storage-optimization">Performance and storage optimization</h3>
<h4 id="optimizing-proof-generation">Optimizing proof generation</h4>
<h4 id="optimizing-verification">Optimizing verification</h4>
<h2 id="notes-on-the-application-architecture">Notes on the application architecture</h2>
<h2 id="appendix">Appendix</h2>
<h3 id="a-generic-commitment-scheme">A Generic commitment scheme</h3>
<p>A (<em>statistically</em>) <em>secure commitment scheme</em> consists of a pair of functions</p>
<p><span class="math display">\[r, m \mapsto c = Comm(r, m)\text{,}\]</span></p>
<p><span class="math inline">\(m\)</span> coming from a set of acceptable messages <span class="math inline">\(M\)</span> and <span class="math inline">\(c\)</span> referred to as <em>commitment</em> to <span class="math inline">\(m\)</span> with <em>trapdoor</em> <span class="math inline">\(r\)</span>, and</p>
<p><span class="math display">\[r, c \mapsto m = Open(r, c)\]</span></p>
<p>referred to as the <em>opening function</em>, such that</p>
<ol style="list-style-type: decimal">
<li>(<em>Correctness</em>) opening the commitment with the correct trapdoor yields the original message, i.e.</li>
</ol>
<p><span class="math display">\[Open(r, Comm(r, m)) = m\]</span></p>
<ol start="2" style="list-style-type: decimal">
<li><p>(<em>Hiding</em>) it is computationally infeasible to infer the original message from the commitment alone, i.e., given <span class="math inline">\(c = Comm(r, m)\)</span>, it is (with overwhelming probability) impossible to find <span class="math inline">\(r&#39;\)</span> such that <span class="math inline">\(m = Open(r^{\prime}, c)\)</span></p></li>
<li><p>(<em>Binding</em>) it is computationally infeasible to anyhow extract from the commitment a message other than the original, i.e., given <span class="math inline">\(c = Comm(r, m)\)</span>, it is (with overwhelming probability) impossible to find <span class="math inline">\(r^{\prime}\)</span> such that <span class="math inline">\(m^{\prime} = Open(r^{\prime}, c) \in M\)</span> and <span class="math inline">\(m^{\prime} \neq m\)</span>.</p></li>
</ol>
<p>Let <em>A</em> commit to a message <span class="math inline">\(m\)</span> with trapdoor <span class="math inline">\(r\)</span> and send the commitment <span class="math inline">\(c\)</span> to <em>B</em>. In view of correctness, the <em>hiding</em> property means that <span class="math inline">\(c\)</span> resembles a box containing <span class="math inline">\(m\)</span> in the hands of <em>B</em>, whose key <span class="math inline">\(r\)</span> is controlled by <em>A</em>: <em>B</em> will never learn <span class="math inline">\(m\)</span> unless <em>A</em> chooses to reveal <em>r</em> to them. On the counterpoint, again in view of correctness, the <em>binding</em> property means that the box can be unlocked by <em>A</em> in only one meaningful way: <em>A</em> cannot fabricate a trapdoor so that opening the box with it leads to any acceptable content other than the original.</p>
<!-- The following scenario is of practical interest: *B* knows a secret *m* and
wants to verify that *A* knows $m$ too, but *A* is unwilling to communicate *m*
explicitly. Instead, *A* hides the content by sending a commitment $c$ to *B*,
which *B* can use at any later moment to verify knowledge of $m$ on behalf of
*A*. More specifically, whenever *B* wishes to verify *A*'s claim of knowledge,
he ask her to send him the trapdoor $r$ used at commitment phase. *B* uses $r$
to open the commitment: if the result is $m$, *B* accepts the claim; otherwise,
due to binding, the claim is rejected. -->
<h3 id="b-generic-zk-snark-scheme">B Generic zk-SNARK scheme</h3>
<h3 id="c-merkle-proof-of-inclusion">C Merkle-proof of inclusion</h3>
</body>
</html>
