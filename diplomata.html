<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
</head>
<body>
<h1 id="anonymous-proof-of-possession-in-the-context-of-diplomata-record-ledger-uc3">Anonymous Proof of Possession in the context of Diplomata Record Ledger (UC3)</h1>
<h2 id="introduction">Introduction</h2>
<p><em>Diplomata</em> is a proposed system for proving and verifying title possession in a privacy-preserving fashion. It involves three kinds of interacting network entities: <em>Holders</em> of qualifications, which they can present to interested parties, <em>Issuers</em> capable of issuing qualifications to holders, and <em>Verifiers</em> able to verify the holders' claims of possessing a title. Awarding of titles, requests of certification, acknowledgments of certification etc. are all recorded in the form of transaction in a blockchain ledger, in order for the involved entities to be held publicly accountable for their actions. Requirements like <em>access control</em> on behalf of the holders, resistance to <em>no honesty</em> and <em>auditability</em> by external observers should also be satisfied.</p>
<p>A <em>ZK-Decryptor Protocol</em> (<em>ZKD</em>) has already been proposed on top of an El-Gamal cryptosystem, that allows holders to (indirectly) prove possession of titles to verifiers. However, the Issuer of the title is heavily involved in the process. Except for an initial certification request and the private communication of the accompanying commitment to the Verifier, the rest of communication takes place between Issuer and Verifier: it is the <em>Issuer</em> who actually commits and generates the proof of award that will be finally verified. More importantly, verification of proof presupposes that the (content of the) title will be decrypted by the Verifier and thus <em>disclosed</em> to them, i.e., &quot;zero-knowledge&quot; does not refer to the qualification' content. Since the title contains as such reference to the Holder's identity, this entails <em>non</em>-anonymity for the Holder.</p>
<p>Purpose of this text is to propose an alternative to the <em>ZKD</em> protocol for the case where the Holder's anonymity is desired and the (content of the) title should not be revealed. This pertains to the following meritocratic scenario. Holder and Verifier meet anonymously online with the requirement that their communication channel remains private and their identities unrevealed. In particular, the Holder wishes to prove possession of a title <span class="math inline">\(t\)</span></p>
<ol style="list-style-type: decimal">
<li>without ever revealing their identity, since the communication must remain anonymous</li>
<li>without disclosing any info about <span class="math inline">\(t\)</span>, except for the fact that it exists among their acquired qualifications</li>
<li>in one single communication step</li>
<li>without involvement of anybody else in that step (say, the Issuer of <span class="math inline">\(t\)</span>), since the communication must remain private</li>
</ol>
<p>The proposed protocol will be referred to as <em>Anonymous Proof of Possession Protocol</em> (<em>APP</em>). Proof of possession should be thought of as proof of <em>inclusion</em> in a set of recordedly awarded titles (possibly of a special kind) strongly correlated to the prover's (unrevealed) identity. In doing so, we will employ the <em>zk-SNARK</em> cryptographic scheme combined with a commitment mechanism. In particular, proof of possession will be a zk-SNARK proof.</p>
<p>Such a construction will partly resemble the <em>ZeroCash</em> anonymous payment scheme, with each title interpreted as 1 BTC (bitcoin) and the holders' commitments recorded in the ledger. There are, however, two major differences:</p>
<ol style="list-style-type: decimal">
<li><p>No &quot;Direct Anonymous Payment&quot; method is here facilitated, that is, transfer of titles(=coins) from holder to holder is <em>not</em> anyhow taken into account. This allows to stay away from the intricacies of the key-address machinery surrounding commitments in the ZeroCash cryptographic flow.</p></li>
<li><p>Except for the Prover(=Holder) and Verifier, a third party, the <em>Issuer</em>, is responsible for recording the Holder's commitment: contrary to the commitment to a coin's serial number, the Holder's commitment to a title's serial number is appended to the ledger not by the Holder, but by the Issuer. Note, however, that this involvement does <em>not</em> violate requirement 4: it takes place <em>prior to</em> generation and transmission of any proof of possession for <span class="math inline">\(t\)</span>. More specifically, <span class="math inline">\(I\)</span> 's role is limited to the preparation of context for these proofs, without ever involving to any of them.</p></li>
</ol>
<p>It should be finally stressed that the here proposed <em>APP</em> protocol is not intended to replace <em>ZKD</em> and should not be considered as an improvement of it. It is rather complementary to it in the context of a <em>Diplomata</em> application, whenever the utmost degree of anonymity is desired. In fact, <em>APP</em> has some practical drawbacks compared to <em>ZKD</em>:</p>
<ol style="list-style-type: decimal">
<li>Being due to non-interactiveness, anonymity of the Holder is at the cost of the Verifier's ability to check for certificate revocation. That is, if certificate revocation is supported by the system, then the proposed proof of possession is only equivalent to a <em>proof of acquisition</em>. This is because certification takes place once (e.g., upon issuance of the title or whenever the Holder wishes) and any subsequent revocation would need the Issuer's involvement in order to be known. If the Verifier wants to verify that a title is <em>still</em> possessed by the Holder, they would need to proceed to a second stage and run some additional, possibly non-anonymous proof-verify session, where the Issuer intermedieates in order to convey info about possible revocation.</li>
<li>Being a zk-SNARK protocol, <em>APP</em>'s setup presupposes a public ceremony for destroying the randomness used in the Common Reference String (CRS) generation.</li>
</ol>
<p>With these limitation in mind, we proceed to the exact description of the protocol. Abstract aspects of the involved primitives are exposed for reference in the Appendix.</p>
<h2 id="the-anonymous-proof-of-possession-app-protocol">The Anonymous Proof of Possession (APP) Protocol</h2>
<p>As usually, an append-only public ledger (say, blockchain) is available, where all actions of network entities are recorded in the form of serial number. Serial numbers can be randomly selected but unique for each action; they are labeled with a tag, indicating the kind of action to record in the ledger. Only a set of predefined tags is acceptable; furthermore, special rules might determine which tags are allowed to be used by the various network entities. For example, only issuers are allowed to append serial numbers with the tag corresponding to title issuance.</p>
<h3 id="preliminary-discussion">Preliminary discussion</h3>
<p>Let <span class="math inline">\(t\)</span> be a title issued by <span class="math inline">\(I\)</span> to a holder <span class="math inline">\(H\)</span>. The (issuance of the) title is assigned by <span class="math inline">\(I\)</span> a unique serial number <span class="math inline">\(s\)</span>, which <span class="math inline">\(I\)</span> possibly records in the ledger. Note that this mere record conveys no info about either <span class="math inline">\(t\)</span> or <span class="math inline">\(H\)</span>, beyond the fact that some title has been issued at some point of history. Consequently, only <span class="math inline">\(I\)</span> can certify that <span class="math inline">\(s\)</span> relates to the particular title acquired by <span class="math inline">\(H\)</span>.</p>
<p>This observation has major effect on the communication between <span class="math inline">\(H\)</span> and a verifier <span class="math inline">\(V\)</span>, to whom <span class="math inline">\(H\)</span> wants to prove knowledge of <span class="math inline">\(t\)</span>: using <span class="math inline">\(s\)</span> alone in order to verify possession of <span class="math inline">\(t\)</span> would necessarily need to involve <span class="math inline">\(I\)</span> and communicate <span class="math inline">\(s\)</span> to them, violating the requirement of privacy. More importantly, having assigned themselves <span class="math inline">\(s\)</span> to the title, <span class="math inline">\(I\)</span> can infer from <span class="math inline">\(s\)</span> both <span class="math inline">\(H\)</span>'s identity and <span class="math inline">\(t\)</span>'s content. Clearly, in order for identity and content to remain secret, <span class="math inline">\(s\)</span> can not be alone used in the private communication between <span class="math inline">\(H\)</span> and <span class="math inline">\(V\)</span>: if <span class="math inline">\(H\)</span> wants to be able to prove possession without having <span class="math inline">\(V\)</span> appeal to <span class="math inline">\(I\)</span>, <span class="math inline">\(s\)</span> must be communicated to <span class="math inline">\(V\)</span> along with some additional quantity.</p>
<p>Due to the binding property, a natural choice is to use a commitment. Assume that a statistically-secure commitment mechanism <span class="math inline">\(Comm\)</span> is available. Whenever <span class="math inline">\(H\)</span> wants to prove possession of <span class="math inline">\(t\)</span> to a verifier <span class="math inline">\(V\)</span>, the holder could, say, send a commitment <span class="math inline">\(c=Comm(r, s)\)</span> along with <span class="math inline">\(s\)</span>, so that <span class="math inline">\(V\)</span> could later open the commitment with <span class="math inline">\(r\)</span> and verify that its content is <span class="math inline">\(s\)</span>. This scenario is severely flawed, since binding of <span class="math inline">\(H\)</span> to <span class="math inline">\(s\)</span> does no way guarantee possession of <span class="math inline">\(t\)</span>: <span class="math inline">\(H\)</span> can commit to arbitrary serial numbers; even if <span class="math inline">\(V\)</span> audits the ledger to check that s appears in it, <span class="math inline">\(H\)</span> could still have committed to the serial number of a title they don't possess. We thus need a further binding of <span class="math inline">\(s\)</span> to <span class="math inline">\(t\)</span>, i.e, a certification that <span class="math inline">\(s\)</span> is <span class="math inline">\(t\)</span>'s serial number. We know only <span class="math inline">\(I\)</span> can give this certification, so any commitment used by <span class="math inline">\(H\)</span> must be beforehand publicly approved by <span class="math inline">\(I\)</span>.</p>
<p>We let <span class="math inline">\(I\)</span> approve and subsequently record <span class="math inline">\(c\)</span> in the ledger. <span class="math inline">\(H\)</span> can now point to the public record <span class="math inline">\(c\)</span> and send <span class="math inline">\(r\)</span> to <span class="math inline">\(V\)</span>, who can then unlock <span class="math inline">\(c\)</span> with <span class="math inline">\(r\)</span> and verify its content. However, consumption of <span class="math inline">\(r\)</span> by the verifier means that a new commitment must be generated by <span class="math inline">\(H\)</span> for each proof-verify session (otherwise a dishonest verifier could leak r to a malicious holder, who could then successfully prove possession of <span class="math inline">\(t\)</span> by simply pointing to <span class="math inline">\(c\)</span> on the public ledger). Consequently, <span class="math inline">\(H\)</span> must repeatedly appeal to <span class="math inline">\(I\)</span> for approval.</p>
<p>We can employ proof-of-knowledge for the purpose of generating only once a commitment and thus minimizing interaction with <span class="math inline">\(I\)</span>. Instead of communicating <span class="math inline">\(r\)</span> to <span class="math inline">\(V\)</span>, the holder could equivalently prove knowledge of the particular trapdoor <span class="math inline">\(r\)</span> which unlocks the <span class="math inline">\(c\)</span> public record. Indeed:</p>
<ol style="list-style-type: decimal">
<li><p>Since this record has been approved by <span class="math inline">\(I\)</span>, verifying the proof is equivalent to verifying possession of <span class="math inline">\(t\)</span> on behalf of <span class="math inline">\(H\)</span>.</p></li>
<li><p>Since <span class="math inline">\(r\)</span> remains secret, <span class="math inline">\(c\)</span> may be uniformly reused by <span class="math inline">\(H\)</span> in all proof-verify sessions concerning <span class="math inline">\(t\)</span>.</p></li>
</ol>
<p>What can this proof-of-knowledge mechanism be? In fact, the holder does not even have to point to the <span class="math inline">\(c\)</span> public record: given <span class="math inline">\(s\)</span>, and assuming that approved commitments are recorded with a tag COMM indicating their nature, <span class="math inline">\(H\)</span> needs only prove the following claim:</p>
<p><span class="math display">\[\text{&quot;I know } r \text{ such that } Comm(r, s) \text{ appears in the public ledger with tag COMM&quot; }\]</span></p>
<p>This statement is obviously NP-complete. Consequently, it can be produced as a zk-SNARK proof upon the predicate</p>
<p><span class="math display">\[F(r, s) = Comm(r, s) \text{ appears in the public ledger with tag COMM }\]</span></p>
<p>In other words, the desired proof-of-knowledge mechanism can be a zk-SNARK cryptosystem with public predicate <span class="math inline">\(F\)</span>. The trapdoor <span class="math inline">\(r\)</span> serves as the secret witness to the serial number <span class="math inline">\(s\)</span>, which serves in turn as the public instance of the predicate.</p>
<p>Till now we have only adjusted part of the <em>ZeroCash</em> protocol to the <em>Diplomata</em> context, where awarded titles are interpreted as 1 BTC. In ZeroCash, a holder's commitment to a particular bitcoin collection is approved and recorded by means of an escrow (e.g., when physical money is exchanged for electronic cash). In our protocol, this is equivalent to the certification on behalf of <span class="math inline">\(I\)</span> that <span class="math inline">\(c = Comm(r, s)\)</span> is a commitment to <span class="math inline">\(s\)</span>: in order to record <span class="math inline">\(c\)</span> in the public ledger, the issuer must first ensure that the holder has indeed committed to <span class="math inline">\(s\)</span> and not any arbitrary value. On the other hand, the trapdoor <span class="math inline">\(r\)</span> must remain eternally secret. In particular, <span class="math inline">\(H\)</span> cannot communicate <span class="math inline">\(r\)</span> to <span class="math inline">\(I\)</span> in order for the latter to unlock the commitment and certify its content: a dishonest <span class="math inline">\(I\)</span> could leak r to a malicious holder, who would then successfully prove possession of <span class="math inline">\(t\)</span> by simply generating a proof on top of the zk-SNARK infrastructure. We have to solve the following problem: how can the issuer certify commitment to the correct serial number without knowing the secret trapdoor?</p>
<p>To do so, we will take advantage of the commitment's internal mechanism. The scheme particularly suited for our purpose is the <em>Pedersen commitment scheme</em>, as will be explained in the following section.</p>
<h4 id="certification">Certification</h4>
<p>Let <span class="math inline">\(p\)</span> be a large prime, <span class="math inline">\(g\)</span> a generator of the group of quadratic residues in <span class="math inline">\(\mathbb{Z}_p^\star\)</span> and <span class="math inline">\(h\)</span> a randomly chosen residue. Fixing these public parameters, the <em>Pedersen commitment scheme</em> is defined as</p>
<p><span class="math display">\[Comm(r, s) = g^r h^s\]</span></p>
<p>(involved operations taken <span class="math inline">\(mod\)</span> <span class="math inline">\(p\)</span>). Security of the scheme (the hiding and binding properties) depends on further assumptions upon <span class="math inline">\(p\)</span> and <span class="math inline">\(g\)</span> to be stipulated when needed. We are here interested in the following key observation: Let <span class="math inline">\(c = Comm(r, s)\)</span> be the Pedersen commitment of <em>A</em> to a secret <span class="math inline">\(s\)</span>, which is known to both <em>A</em> and <em>B</em>. If <em>A</em> sends <span class="math inline">\(g^r\)</span> and <span class="math inline">\(c\)</span> to <em>B</em>, then</p>
<ol style="list-style-type: decimal">
<li><em>B</em> can check whether <span class="math inline">\(c\)</span> is a commitment to <span class="math inline">\(s\)</span> without knowing the trapdoor <span class="math inline">\(r\)</span></li>
<li><em>B</em> cannot infer the value of <em>r</em></li>
</ol>
<p>Indeed, knowing already <span class="math inline">\(s\)</span>, B can compute <span class="math inline">\(h^s\)</span> and check whether <span class="math inline">\(c\)</span> is equal to <span class="math inline">\(g^r h^s\)</span>. If <em>A</em> had committed to any <span class="math inline">\(s^\prime \neq s\)</span>, i.e., <span class="math inline">\(c = g^r h^{s&#39;}\)</span>, then, in order to deceive <em>B</em>, they would need to fabricate <span class="math inline">\(r^\prime\)</span> such that <span class="math inline">\(g^r h^{s&#39;} = g^{r&#39;} h^s\)</span> or, equivalently, solve</p>
<p><span class="math display">\[r^\prime = \log g^r h^{s^\prime-s}\]</span></p>
<p>which is computationally infeasible in view of discrete logarithm hardness. Based on the same hardness assumption, <em>B</em> cannot infer <em>r</em> from either <span class="math inline">\(g^r\)</span> or <span class="math inline">\(h^s\)</span> or their combinations.</p>
<p>The above observation applies to the <em>Diplomata</em> context by fixing the Pedersen schema as the system's commitment mechanism. Let a holder <span class="math inline">\(H\)</span> and an issuer <span class="math inline">\(I\)</span> have the roles of <em>A</em> resp. <em>B</em>, <span class="math inline">\(s\)</span> be the serial number of a title <span class="math inline">\(t\)</span> issued by <span class="math inline">\(I\)</span> to <span class="math inline">\(H\)</span> and <span class="math inline">\(c\)</span> the holder's commitment to that number. In order to repeatedly use <span class="math inline">\(c\)</span> as certificate in future proof-verify sessions, the holder requests from <span class="math inline">\(I\)</span> to approve their commitment and append it to the public ledger. More accurately, after committing with a randomly chosen trapdoor <span class="math inline">\(r\)</span>, <span class="math inline">\(H\)</span> sends <span class="math inline">\(s\)</span>, <span class="math inline">\(g^r\)</span> and <span class="math inline">\(c\)</span> to <span class="math inline">\(I\)</span> with the request to certify <span class="math inline">\(c\)</span> as commitment to <span class="math inline">\(s\)</span> and subsequently append it to the ledger. <span class="math inline">\(I\)</span> first looks in their database of awarded titles to see if <span class="math inline">\(s\)</span> corresponds indeed to any of them. If yes, <span class="math inline">\(I\)</span> proceeds to certification of <span class="math inline">\(c\)</span> by means of <span class="math inline">\(g^r\)</span>. In case of success, <span class="math inline">\(I\)</span> appends <span class="math inline">\(c\)</span> to the ledger; otherwise the holder's request is rejected. The trapdoor remains unrevealed to the issuer as should.</p>
<h3 id="formal-description">Formal description</h3>
<h4 id="setup">Setup</h4>
<p>Let <em>L</em> denote the public ledger. Among possibly others, we define a tag</p>
<p style="text-align: center;">
COMM,
</p>
<p>indicating a commitment to an awarded title's serial number, and specify that <em>only Issuers have the right to append records with this tag to the ledger</em>.</p>
<p>We fix a sufficiently high security parameter <span class="math inline">\(n\)</span> and randomly choose <span class="math inline">\(p = 2q + 1\)</span> to be a strong <span class="math inline">\((n + 1)\)</span>-prime (i.e., such that <span class="math inline">\(q\)</span> is prime). Denoting by <span class="math inline">\(Q\subset\mathbb{Z}_p^\star\)</span> the group of quadratic residues, we randomly fix a generator <span class="math inline">\(g\)</span> of <span class="math inline">\(Q\)</span> and a residue <span class="math inline">\(h \in Q\)</span>. We denote by</p>
<p><span class="math display">\[\mathbb{Z}_p^\star\times\mathbb{Z}_p\ni(r, s) \mapsto Comm(r, s) = g^r h^s\]</span></p>
<p>the Pedersen function over the pair <span class="math inline">\((g, h)\)</span>. Under the above assumptions, discrete log hardness becomes plausible and <span class="math inline">\(Comm\)</span> may be considered as a statistically-secure commitment mechanism. We specify that <em>serial numbers assigned by Issuers to titles be contained in</em> <span class="math inline">\(\mathbb{Z}_p\)</span>.</p>
<p>We next consider the predicate</p>
<p><span class="math display">\[F(r, s) = Comm(r, s) \text{ appears in } L \text{ with tag COMM }\]</span></p>
<p>Both lookup in <span class="math inline">\(L\)</span> and evaluation of <span class="math inline">\(Comm\)</span> have polynomial time complexity. Consequently, for any <span class="math inline">\(s\)</span>, the statement</p>
<p><span class="math display">\[\text{I know } r \text{ such that } F(r, s) = 1\]</span></p>
<p>is NP-complete with respect to <span class="math inline">\(r\)</span>. This allows to use <span class="math inline">\(F\)</span> as the public predicate of a zk-SNARK cryptosystem, where the trapdoor is thought of as the private witness to the serial number. More accurately, feeding <span class="math inline">\(F\)</span> to a CRS-generator, we denote by</p>
<p style="text-align: center;">
CRS = <span class="math inline">\((pk, vk)\)</span>
</p>
<p>the pair of produced proving and verifying keys of the induced zk-SNARK cryptosystem. We will denote by</p>
<p><span class="math display">\[(\mathit{pk}, s, r) \mapsto \pi = \text{Prover}(\mathit{pk}, s, r),\]</span> <span class="math display">\[(vk, s, \pi) \mapsto \text{Verifier}(\mathit{vk}, s, \pi) \in \{0, 1\}\]</span></p>
<p>the Prover, resp. Verifier algorithms of the zk-SNARK cryptosystem. We specify that <em>every Holder can internally run a Prover and Verifiers coincide with Verifiers of the</em> zk-SNARK <em>cryptosystem</em>.</p>
<h4 id="cryptographic-flow">Cryptographic flow</h4>
<p>Let <span class="math inline">\(t\)</span> be a title issued by issuer <span class="math inline">\(I\)</span> to a holder <span class="math inline">\(H\)</span>. Upon issuance of <span class="math inline">\(t\)</span>, the preliminary Steps 1-3 must take place.</p>
<ol style="list-style-type: decimal">
<li><p>Issuer <span class="math inline">\(I\)</span> uniquely assigns to <span class="math inline">\(t\)</span> a serial number <span class="math inline">\(s\in\mathbb{Z}_p\)</span>, which they store in their local database as the identifier of <span class="math inline">\(t\)</span>. (For transparency or history reasons, <span class="math inline">\(I\)</span> might record <span class="math inline">\(s\)</span> in the public ledger, but this is irrelevant to what follows.)</p></li>
<li><p>Issuer <span class="math inline">\(I\)</span> privately communicates <span class="math inline">\(s\)</span> to holder <span class="math inline">\(H\)</span>.</p></li>
<li><p>Holder <span class="math inline">\(H\)</span> stores <span class="math inline">\(s\)</span> in their local database as the identifier of <span class="math inline">\(t\)</span>.</p></li>
</ol>
<p>In order for <span class="math inline">\(H\)</span> to be able to repeatedly prove possession of <span class="math inline">\(t\)</span>, they must enter at will the following certification phase (once per <span class="math inline">\(t\)</span>).</p>
<h5 id="certification-phase-once-per-title">Certification phase (once per title)</h5>
<ol start="4" style="list-style-type: decimal">
<li><p>Holder <span class="math inline">\(H\)</span> randomly chooses a trapdoor <span class="math inline">\(r\)</span> and computes <span class="math inline">\(c = Comm(r, s)\)</span>.</p></li>
<li><p>Holder <span class="math inline">\(H\)</span> stores <span class="math inline">\(r\)</span> in their local database as the private witness to <span class="math inline">\(s\)</span>.</p></li>
<li><p>Holder <span class="math inline">\(H\)</span> privately communicates <span class="math inline">\((g^r, c, s)\)</span> to issuer <span class="math inline">\(I\)</span> with the request to approve <span class="math inline">\(c\)</span> and append it to <span class="math inline">\(L\)</span>.</p></li>
<li><p>Issuer <span class="math inline">\(I\)</span> checks their local database to see if <span class="math inline">\(s\)</span> corresponds indeed to any title awarded to <span class="math inline">\(H\)</span>. If yes, issuer <span class="math inline">\(I\)</span> proceeds to Step 8; otherwise <span class="math inline">\(H\)</span>'s request is rejected and the certification phase terminates.</p></li>
<li><p>Issuer <span class="math inline">\(I\)</span> computes <span class="math inline">\(h^s\)</span> and uses it to check if <span class="math inline">\(c = g^r h^s\)</span>. If yes, <span class="math inline">\(I\)</span> proceeds to Step 9; otherwise <span class="math inline">\(H\)</span>'s request is rejected and the certification phase terminates.</p></li>
<li><p>Issuer <span class="math inline">\(I\)</span> appends <span class="math inline">\(c\)</span> to <span class="math inline">\(L\)</span> with tag COMM and informs <span class="math inline">\(H\)</span>.</p></li>
</ol>
<p>Note that a dishonest issuer cannot avoid recording <span class="math inline">\(c\)</span> to the public ledger, since a honest holder can anytime audit <span class="math inline">\(L\)</span> to see if their commitment has been appended.</p>
<h5 id="proof-verify-session">Proof-verify session</h5>
<p>Let a verifier <span class="math inline">\(V\)</span> meet anonymously <span class="math inline">\(H\)</span> online. <span class="math inline">\(H\)</span> wants to prove that they possess a title (in this case: <span class="math inline">\(t\)</span>) by only referring to its serial number, (i.e., without revealing part of its content).</p>
<ol start="10" style="list-style-type: decimal">
<li><p>Holder <span class="math inline">\(H\)</span> detects in their local database the serial number <span class="math inline">\(s\)</span>, which identifies <span class="math inline">\(t\)</span>, along with the private witness <span class="math inline">\(r\)</span> to it.</p></li>
<li><p>Holder <span class="math inline">\(H\)</span> runs the zk-SNARK Prover over <span class="math inline">\((r, s)\)</span> to generate <span class="math inline">\(\pi = \text{Prover}(\mathit{pk}, s, r)\)</span></p></li>
</ol>
<p>The produced <span class="math inline">\(\pi\)</span> is namely the zk-SNARK proof that <span class="math inline">\(H\)</span> knows <span class="math inline">\(r\)</span> such that <span class="math inline">\(Comm(r, s)\)</span> appears in the ledger as a certified commitment. Equivalently, <span class="math inline">\(\pi\)</span> proves possession of an awarded title on behalf of <span class="math inline">\(H\)</span>.</p>
<ol start="12" style="list-style-type: decimal">
<li><p>Holder <span class="math inline">\(H\)</span> privately communicates <span class="math inline">\((\pi, s)\)</span> to <span class="math inline">\(V\)</span>.</p></li>
<li><p>Verifier <span class="math inline">\(V\)</span> feeds <span class="math inline">\(\pi\)</span> to the zk-SNARK Verifier, <span class="math inline">\(ans = \text{Verifier}(\mathit{vk}, s, \pi)\)</span>.</p></li>
<li><p>If <span class="math inline">\(ans = 1\)</span>, <span class="math inline">\(V\)</span> accepts <span class="math inline">\(H\)</span>'s claim of knowledge; otherwise the claim is rejected.</p></li>
</ol>
<h3 id="security-proof-and-honesty-assumptions">Security proof and honesty assumptions</h3>
<p>Note that, assuming security of the certification phase, security of the proof-verify session depends entirely on the completeness and soundness of the underlying zk-SNARK cryptosystem (no honesty assumptions about <span class="math inline">\(H\)</span> and <span class="math inline">\(V\)</span>). Consequently, we only need prove security of the certification phase under specific honesty assumptions about <span class="math inline">\(H\)</span> and <span class="math inline">\(I\)</span>. These assumptions are not stronger than the honesty assumptions made of the ZKD protocol.</p>
<p>...</p>
<h3 id="performance-and-storage-optimization">Performance and storage optimization</h3>
<h4 id="optimizing-commitment-detection-in-the-public-ledger">Optimizing commitment detection in the public ledger</h4>
<h4 id="optimizing-verification">Optimizing verification</h4>
<h2 id="notes-on-the-application-architecture">Notes on the application architecture</h2>
<h2 id="appendix">Appendix</h2>
<h3 id="a-generic-commitment-scheme">A Generic commitment scheme</h3>
<p>A (<em>statistically</em>) <em>secure commitment scheme</em> consists of a pair of functions</p>
<p><span class="math display">\[r, m \mapsto c = Comm(r, m)\text{,}\]</span></p>
<p><span class="math inline">\(m\)</span> coming from a set of acceptable messages <span class="math inline">\(M\)</span> and <span class="math inline">\(c\)</span> referred to as <em>commitment</em> to <span class="math inline">\(m\)</span> with <em>trapdoor</em> <span class="math inline">\(r\)</span>, and</p>
<p><span class="math display">\[r, c \mapsto m = Open(r, c)\]</span></p>
<p>referred to as the <em>opening function</em>, such that</p>
<ol style="list-style-type: decimal">
<li>(<em>Correctness</em>) opening the commitment with the correct trapdoor yields the original message, i.e.</li>
</ol>
<p><span class="math display">\[Open(r, Comm(r, m)) = m\]</span></p>
<ol start="2" style="list-style-type: decimal">
<li><p>(<em>Hiding</em>) it is computationally infeasible to infer the original message from the commitment alone, i.e., given <span class="math inline">\(c = Comm(r, m)\)</span>, it is (with overwhelming probability) impossible to find <span class="math inline">\(r&#39;\)</span> such that <span class="math inline">\(m = Open(r^{\prime}, c)\)</span></p></li>
<li><p>(<em>Binding</em>) it is computationally infeasible to anyhow extract from the commitment a message other than the original, i.e., given <span class="math inline">\(c = Comm(r, m)\)</span>, it is (with overwhelming probability) impossible to find <span class="math inline">\(r^{\prime}\)</span> such that <span class="math inline">\(m^{\prime} = Open(r^{\prime}, c) \in M\)</span> and <span class="math inline">\(m^{\prime} \neq m\)</span>.</p></li>
</ol>
<p>Let <em>A</em> commit to a message <span class="math inline">\(m\)</span> with trapdoor <span class="math inline">\(r\)</span> and send the commitment <span class="math inline">\(c\)</span> to <em>B</em>. In view of correctness, the <em>hiding</em> property means that <span class="math inline">\(c\)</span> resembles a box containing <span class="math inline">\(m\)</span> in the hands of <em>B</em>, whose key <span class="math inline">\(r\)</span> is controlled by <em>A</em>: <em>B</em> will never learn <span class="math inline">\(m\)</span> unless <em>A</em> chooses to reveal <em>r</em> to them. On the counterpoint, again in view of correctness, the <em>binding</em> property means that the box can be unlocked by <em>A</em> in only one meaningful way: <em>A</em> cannot fabricate a trapdoor so that opening the box with it leads to any acceptable content other than the original.</p>
<h3 id="b-generic-zk-snark-scheme">B Generic zk-SNARK scheme</h3>
<p>A zk-SNARK (Zero-Knowledge Succinct Non-interactive ARgument of Knowledge) is a general purpose cryptographic scheme for generating and verifying zero-knowledge proofs in efficient and non-interactive fashion. Statements to be proven are claims of knowledge of a quantity <em>w</em> (called <em>withness</em>) satisfying <em>F(x, w)</em>, where <em>x</em> is a public quantity (called <em>instance</em>) and <em>F</em> is a public relation (called <em>predicate</em>). More accurately, without revealing info about <em>w</em>, the prover wishes to generate a proof of the following statement:</p>
<p><span class="math display">\[
\text{given } x \in X \text{ and } F: X \times W \mapsto \{0,
        1\}, \text{ I know a } w \text{ such that } F(x, w) = 1
\]</span></p>
<p>where <span class="math inline">\(X\)</span> is the set of acceptable public instances, <span class="math inline">\(W\)</span> is the set of acceptable private witnesses and 0, 1 hold their usual logical meanings. For example, if the verifier were a web server holding a database of hashed passwords and the prover were the web client of a registered user, the latter does not need to send their password <em>w</em> (as cleartext or in disguise) in order to login, but only a proof of the above statement with predicate:</p>
<p><span class="math display">\[ F(x, w) := \{H(w) = x\}\]</span></p>
<p>where <span class="math inline">\(H\)</span> is the hash function used by the server, <em>W</em> being the preimage set and <span class="math inline">\(X\)</span> the set of stored hashed passwords in the database. To give a more relevant example from the cryptocurrency framework, if <span class="math inline">\(w\)</span> were the encoding of the private payment details of a particular transaction and <span class="math inline">\(x\)</span> the encrypted version of this data, then the predicate <span class="math inline">\(F\)</span> would typically be</p>
<p><span class="math display">\[ F(x, w) = \{w \text{ is a well-formed transaction and } x
        \text{ is the encryption of it}\} \]</span></p>
<p>Note that <span class="math inline">\(F\)</span> is predefined and fixed, which allows for <em>non-interactive</em> mode (see below). Generation and verification of proofs for various witness-instance pairs <span class="math inline">\((w, x)\)</span> is instead a massively repeated procedure. Efficiency of the cryptosystem refers thus not to its initial setup (which only involves <span class="math inline">\(F\)</span>) but to the generation and verification of proofs (involving arbitrary instantiations of <span class="math inline">\((w, x)\)</span> pairs), which naturally leads to the notion of <em>succinctness</em> (see below).</p>
<h4 id="predicate-reduction">Predicate reduction</h4>
<p>In theory, any NP-complete statement which is expressible in the above form may serve as the fixed public predicate of a zk-SNARK cryptosystem. However, transforming the predicate so that it be amenable to low-level cryptographic operations is a genuine challenge. That is, except if following recipes, configuration of the cryptosystem may well be a non-trivial step from the implementors' viewpoint.</p>
<p>After completion of the initial setup, the predicate <span class="math inline">\(F\)</span> may be thought of as a fixed circuit of logical gates. In a blockchain context, this means to encode in the form of a circuit the consensus rules of the network. Satisfaction of <span class="math inline">\(F\)</span> for a witness-instance pair <span class="math inline">\((w, x)\)</span> emulates a particular state of the circuit after running it with that input. zk-SNARK libraries usually avail a mechanism for modelling predicates as logical circuits which resembles the concept of <em>protoboard</em> (prototyping board) from electrical engineering: the cryptosystem's configuration presupposes allocation of <span class="math inline">\(F\)</span>'s &quot;chips&quot; to the protoboard.</p>
<p>This is however only a convenient abstraction. What in fact one must do is appropriately reduce the NP-statement <span class="math inline">\(F\)</span> to a quadratic system of polynomial equations. Satisfiability of <span class="math inline">\(F\)</span> for a given pair <span class="math inline">\((w, x)\)</span> amounts to <span class="math inline">\((x, w)\)</span> being (with overwhelming probability) a solution to this system of equations. More specifically, it has been proven that any NP-complete statement can be reduced to such system of a special kind, usually referred to as a <em>set of quadratic constraints</em>, with each zk-SNARK proof attesting that this set of constraints is satisfied by some concrete input. Further results show that any set of quadratic constraints can be conveniently flattened to what is known as <em>R1CS</em> (<em>Rank 1 Constraint System</em>). Predicate reduction amounts thus to reformulating an NP-complete statement as R1CS.</p>
<h4 id="cryptographic-flow-1">Cryptographic flow</h4>
<p>We expose here the ZS-NARK cryptographic flow for reference, in order to gradually attain semi-formal language and terminology. The flow involves three basic algorithms run by homonymous and mutually independent components: <em>Setup</em>, <em>Prover</em> and <em>Verifier</em>. How these components are distributed among network entities depends on the protocol under implementation.</p>
<p>The Setup algorithm is typically run once by a unanimously trusted party. It is fed with a R1CS (i.e., the fixed public predicate <em>F</em>) and outputs the public CRS (<em>Common Reference String</em>) involved in any subsequent proof generation and verification. In particular, the CRS consists of a proving key <em>pk</em> (uniformly used by all Provers) and a uniquely correlated verification key <em>vk</em> (uniformly used by all Verifiers). Computation of CRS involves also a once used randomness <span class="math inline">\(\mathit{lambda}\)</span>, so that it can formally be expressed as follows:</p>
<p><span class="math display">\[ (F, \mathit{lambda}) \mapsto \text{CRS} := (pk, vk) =
   \mathrm{Setup}(F, \mathit{lambda})\]</span></p>
<p>It is essential that <span class="math inline">\(\mathit{lambda}\)</span> remains forever secret: leakage of randomness would allow a malicious prover to generate false proofs that can erroneously be verified. Trustedness of the Setup party must thus be equivalent to the unanimously accepted guarantee, that the <span class="math inline">\(\mathit{lambda}\)</span> parameter has irreversibly been eliminated after CRS generation (which is the reason for the destruction ceremonies surrounding ZCash etc.).</p>
<p>Upon every proof generation, the Prover is fed with a public instance <span class="math inline">\(x\)</span> and a secret witness <span class="math inline">\(w\)</span> for it. Using the proving part <span class="math inline">\(\mathit{pk}\)</span> of the CRS, the prover generates a proof <span class="math inline">\(\pi\)</span> attesting that <span class="math inline">\(F(x, \cdot)\)</span> is satisfiable by some known <span class="math inline">\(w\)</span>, without disclosing any info about <span class="math inline">\(w\)</span> (i.e., except for the claim that it is known). This can formally be expressed as</p>
<p><span class="math display">\[ (\mathit{pk}, x, w) \mapsto \pi = \text{Prover}(\mathit{pk}, x, w) \]</span></p>
<p>The Verifier uses the verifying part <span class="math inline">\(\mathit{vk}\)</span> of the CRS to operate upon the provided proof, accepting or rejecting according to whether it was found to be valid, resp. invalid:</p>
<p><span class="math display">\[ (vk, x, \pi) \mapsto \text{Verifier}(vk, x, \pi) \in \{0, 1\} \]</span></p>
<p>Note that typically anyone can run a Verifier.</p>
<p>The whole flow is summarized in the following figure:</p>
<p>...[Figure] (1)</p>
<p>In this context, the zk-SNARK properties are formalized as follows:</p>
<ul>
<li><p><em>zk</em> (<em>Zero Knowledge</em>): The generated proof conveys no info about <span class="math inline">\(w\)</span> beyond the claim of it being known, i.e., that <span class="math inline">\(F(x, .)\)</span> is satisfied by it.</p></li>
<li><p><em>S</em> (<em>Succint</em>): The size of proofs is small, constant and independent of the system's constraints and public inputs. More accurately, ignoring dependence on security parameters, proof generation is <span class="math inline">\(O(1)\)</span> and verification is <span class="math inline">\(O(k)\)</span>, where <span class="math inline">\(k\)</span> stands for the proof uniform bitsize. The bottleneck of initial setup needs not be taken into account.</p></li>
<li><p><em>N</em> (<em>Non-interactive</em>): The only interaction between Prover and Verifier is the transmission of the produced proof (one communication step). Any intermediate computation required for proof generation and verification has been absorbed in the precomputation of the CRS (involved via usage of <span class="math inline">\(\mathit{pk}\)</span> and <span class="math inline">\(\mathit{vk}\)</span>).</p></li>
</ul>
<p>Generic requirements may also be formalized as follows:</p>
<ul>
<li><em>Completeness</em>: Correct proofs (i.e., generated upon a correct witness by a honest prover) always verify. More accurately,</li>
</ul>
<p><span class="math display">\[
\begin{align*}
&amp;\textrm{for any } \pi =
\mathrm{Prover}(pk, x, w) \textrm{ such that } F(x, w) = 1,\\
&amp;\textrm{there holds } \mathrm{Verifier}(vk, x, \pi) = 1
\end{align*}
\]</span></p>
<ul>
<li><em>Soundness</em>: No false proof (i.e., generated upon incorrect witness by a malicious prover) ever verifies. More accurately,</li>
</ul>
<p><span class="math display">\[
\begin{align*}
&amp;\textrm{for any } x \textrm{ such that } F(x, .)
\textrm{ not satisfiable, there exists no } w \text{ such that } \\
&amp;\mathrm{Verifier}(vk, x, \pi) = 1 \text{ with } \pi =
\mathrm{Prover}(pk, x, w)
\end{align*}
\]</span></p>
<h4 id="optimizing-verification-with-preprocessed-keys">Optimizing verification with preprocessed keys</h4>
<p>For the purpose of faster verification, <span class="math inline">\(vk\)</span> can be further processed during the initial setup, yielding a so called <em>preprocessed</em> verification key <span class="math inline">\(pvk\)</span>. In particular, a small amount of extra precomputed info can be added to it, in which case the Verifier algorithm must also be modified appropriately (<em>online</em> Verifier). In this case, Figure 1 transforms as follows:</p>
<p>... [Figure] (2)</p>
<p>Note that proof generation is not affected by the usage of preprocessed verification keys.</p>
<h3 id="c-merkle-proof-of-inclusion">C Merkle-proof of inclusion</h3>
</body>
</html>
