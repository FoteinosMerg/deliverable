<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
</head>
<body>
<h1 id="anonymous-proof-of-possession-in-the-context-of-diplomata-record-ledger-uc3">Anonymous Proof of Possession in the context of Diplomata Record Ledger (UC3)</h1>
<h2 id="introduction">Introduction</h2>
<p><em>Diplomata</em> is a proposed system for proving and verifying title possession in a privacy-preserving fashion. It involves three kinds of interacting network entities: <em>Holders</em> of qualifications, which they can present to interested parties, <em>Issuers</em> capable of issuing qualifications to holders, and <em>Verifiers</em> able to verify the holders' claims of possessing a title. Awarding of titles, requests of certification, acknowledgments of certification etc. are all recorded in the form of transaction in a blockchain ledger, in order for the involved entities to be held publicly accountable for their actions. Requirements like access control on behalf of the holders, resistance to (some level of) no honesty and auditability by external observers should also be satisfied.</p>
<p>A <em>ZK-Decryptor Protocol</em> (<em>ZKD</em>) has already been proposed on top of an El-Gamal cryptosystem, that allows holders to (indirectly) prove possession of titles to verifiers. However, the Issuer of the title is heavily involved in the process. Except for an initial certification request and the private communication of the accompanying commitment to the Verifier, the rest of communication takes place between Issuer and Verifier: it is the <em>Issuer</em> who actually commits and generates the proof of award that will be finally verified. More importantly, verification of proof presupposes that the (content of the) title will be decrypted by the Verifier and thus <em>disclosed</em> to them, i.e., &quot;zero-knowledge&quot; does not refer to the qualification's content. Since the title contains as such reference to the Holder's identity, this entails <em>non</em>-anonymity for the Holder.</p>
<p>Purpose of this text is to propose an alternative to the <em>ZKD</em> protocol for the case where the Holder's anonymity is desired and the (content of the) title should not be revealed. This pertains to the following meritocratic scenario. Holder and Verifier meet anonymously online with the requirement that their communication channel remains private and their identities unrevealed. In particular, the Holder wishes to prove possession of a title <span class="math inline">\(t\)</span></p>
<ol style="list-style-type: decimal">
<li>without ever revealing their identity, since the communication must remain anonymous</li>
<li>without disclosing any info about <span class="math inline">\(t\)</span>, except for the fact that it exists among their acquired qualifications</li>
<li>in one single communication step</li>
<li>without involvement of anybody else in that step (say, the Issuer of <span class="math inline">\(t\)</span>), since the communication must remain private</li>
</ol>
<p>The proposed protocol will be referred to as <em>Anonymous Proof of Possession Protocol</em> (<em>APP</em>). Proof of possession should be thought of as proof of inclusion in a set of recordedly awarded titles (possibly of a special kind) strongly correlated to the prover's (unrevealed) identity. In doing so, we will employ the <em>zk-SNARK</em> cryptographic scheme combined with a commitment mechanism. In particular, proof of possession will be a zk-SNARK proof.</p>
<p>Such a construction will partly resemble the <em>ZeroCash</em> anonymous payment scheme, with each title interpreted as 1 BTC (bitcoin) and the holders' commitments recorded in the ledger. There are, however, two major differences:</p>
<ol style="list-style-type: decimal">
<li><p>No &quot;Direct Anonymous Payment&quot; method is here facilitated, that is, transfer of titles(=coins) from holder to holder is not anyhow taken into account. This allows to stay away from the intricacies of the key-address machinery surrounding commitments in the ZeroCash cryptographic flow.</p></li>
<li><p>Except for the Prover(=Holder) and Verifier, a third party, the <em>Issuer</em>, is must be here involved in order to record the Holder's commitment. Note, however, that this involvement does not violate requirement 4: it takes place <em>prior to</em> generation and transmission of any proof of possession for <span class="math inline">\(t\)</span>. More accurately, <span class="math inline">\(I\)</span> 's role is limited to the preparation of context for these proofs, without ever involving to any of them.</p></li>
</ol>
<p>It should be finally stressed that the here proposed <em>APP</em> protocol is not intended to replace <em>ZKD</em> and should not be considered as an improvement of it. It is rather complementary to it in the context of a <em>Diplomata</em> application, whenever the utmost degree of anonymity is desired. In fact, <em>APP</em> has some practical drawbacks compared to <em>ZKD</em>:</p>
<ol style="list-style-type: decimal">
<li>Being due to non-interactiveness, anonymity of the Holder is at the cost of the Verifier's ability to check for certificate revocation. That is, if certificate revocation is supported by the system, then the proposed proof of possession is only equivalent to a <em>proof of acquisition</em>. This is because certification takes place once (e.g., upon issuance of the title or whenever the Holder wishes) and any subsequent revocation would need the Issuer's involvement in order to be known. If the Verifier wants to verify that a title is <em>still</em> possessed by the Holder, they would need to proceed to a second stage and run some additional, possibly non-anonymous proof-verify session, where the Issuer intermedieates in order to convey info about possible revocation.</li>
<li>Being a zk-SNARK protocol, <em>APP</em>'s setup presupposes a public ceremony for destroying the randomness used in the generation of the Common Reference String (CRS).</li>
</ol>
<p>With these limitation in mind, we proceed to the exact description of the protocol. Abstract aspects of the involved primitives are exposed for reference in the Appendix.</p>
<h2 id="the-anonymous-proof-of-possession-app-protocol">The Anonymous Proof of Possession (APP) Protocol</h2>
<p>As usually, an append-only public ledger (say, blockchain) is available, where all actions of network entities are recorded in the form of serial number. Serial numbers can be randomly selected but unique for each action; they are labeled with a tag, indicating the kind of action to record in the ledger. Only a set of predefined tags is acceptable; furthermore, special rules might determine which tags are allowed to be used by the various network entities. For example, only issuers are allowed to append serial numbers with the tag corresponding to title issuance.</p>
<h3 id="preliminary-discussion">Preliminary discussion</h3>
<p>Let <span class="math inline">\(t\)</span> be a title issued by <span class="math inline">\(I\)</span> to a holder <span class="math inline">\(H\)</span>. The (issuance of the) title is assigned by <span class="math inline">\(I\)</span> a unique serial number <span class="math inline">\(s\)</span>, which <span class="math inline">\(I\)</span> possibly records in the ledger. Note that this mere record conveys no info about either <span class="math inline">\(t\)</span> or <span class="math inline">\(H\)</span>, beyond the fact that some title has been issued at some point of history. Consequently, only <span class="math inline">\(I\)</span> can certify that <span class="math inline">\(s\)</span> relates to the particular title acquired by <span class="math inline">\(H\)</span>.</p>
<p>This observation has major effect on the communication between <span class="math inline">\(H\)</span> and a verifier <span class="math inline">\(V\)</span>, to whom <span class="math inline">\(H\)</span> wants to prove possession of <span class="math inline">\(t\)</span>: using <span class="math inline">\(s\)</span> alone in order to verify possession of <span class="math inline">\(t\)</span> would necessarily need to involve <span class="math inline">\(I\)</span> and communicate <span class="math inline">\(s\)</span> to them, violating the requirement of privacy. More importantly, having assigned themselves <span class="math inline">\(s\)</span> to <span class="math inline">\(t\)</span>, <span class="math inline">\(I\)</span> can infer from <span class="math inline">\(s\)</span> both <span class="math inline">\(H\)</span>'s identity and <span class="math inline">\(t\)</span>'s content. Clearly, in order for identity and content to remain secret, <span class="math inline">\(s\)</span> can not be alone used in the private communication between <span class="math inline">\(H\)</span> and <span class="math inline">\(V\)</span>: if <span class="math inline">\(H\)</span> wants to be able to prove possession without having <span class="math inline">\(V\)</span> appeal to <span class="math inline">\(I\)</span>, <span class="math inline">\(s\)</span> must be communicated to <span class="math inline">\(V\)</span> along with some additional quantity.</p>
<p>Due to the binding property, a natural choice is to use a commitment. Assume that a statistically secure commitment mechanism <span class="math inline">\(Comm\)</span> is available. Whenever <span class="math inline">\(H\)</span> wants to prove possession of <span class="math inline">\(t\)</span> to a verifier <span class="math inline">\(V\)</span>, the holder could, say, send a commitment <span class="math inline">\(c=Comm(r, s)\)</span> along with <span class="math inline">\(s\)</span>, so that <span class="math inline">\(V\)</span> could later open the commitment with <span class="math inline">\(r\)</span> and verify that its content is <span class="math inline">\(s\)</span>. This scenario is severely flawed, since binding of <span class="math inline">\(H\)</span> to <span class="math inline">\(s\)</span> does no way guarantee possession of <span class="math inline">\(t\)</span>: <span class="math inline">\(H\)</span> can commit to arbitrary serial numbers; even if <span class="math inline">\(V\)</span> audits the ledger to check that <span class="math inline">\(s\)</span> appears in it, <span class="math inline">\(H\)</span> could still have committed to the serial number of a title they don't possess. We thus need a further binding of <span class="math inline">\(s\)</span> to <span class="math inline">\(t\)</span>, i.e, a certification that <span class="math inline">\(s\)</span> is the serial number of <span class="math inline">\(t\)</span>. We know only <span class="math inline">\(I\)</span> can give this certification, so any commitment used by <span class="math inline">\(H\)</span> must be beforehand publicly approved by <span class="math inline">\(I\)</span>.</p>
<p>Assuming for the moment that such a certification mechanism is available, we let <span class="math inline">\(I\)</span> approve and subsequently record <span class="math inline">\(c\)</span> in the ledger. <span class="math inline">\(H\)</span> can now point to the public record <span class="math inline">\(c\)</span> and send <span class="math inline">\(r\)</span> to <span class="math inline">\(V\)</span>, who can then unlock <span class="math inline">\(c\)</span> with <span class="math inline">\(r\)</span> and verify its content. However, consumption of <span class="math inline">\(r\)</span> by the verifier means that a new commitment must be generated by <span class="math inline">\(H\)</span> for each proof-verify session (otherwise a dishonest verifier could leak r to a malicious holder, who could then successfully prove possession of <span class="math inline">\(t\)</span> by simply pointing to <span class="math inline">\(c\)</span> on the public ledger). Consequently, <span class="math inline">\(H\)</span> must repeatedly appeal to <span class="math inline">\(I\)</span> for approval. We can employ proof-of-knowledge for the purpose of generating only once a commitment and thus minimize interaction with <span class="math inline">\(I\)</span>. Instead of communicating <span class="math inline">\(r\)</span> to <span class="math inline">\(V\)</span>, the holder could equivalently prove knowledge of the particular trapdoor <span class="math inline">\(r\)</span> which unlocks the <span class="math inline">\(c\)</span> public record. Indeed:</p>
<ol style="list-style-type: decimal">
<li><p>Since this record has been approved by <span class="math inline">\(I\)</span>, verifying the proof is equivalent to verifying possession of <span class="math inline">\(t\)</span> on behalf of <span class="math inline">\(H\)</span>.</p></li>
<li><p>Since <span class="math inline">\(r\)</span> remains secret, <span class="math inline">\(c\)</span> may be uniformly reused by <span class="math inline">\(H\)</span> in all proof-verify sessions concerning <span class="math inline">\(t\)</span>.</p></li>
</ol>
<p>What can this proof-of-knowledge mechanism be? In fact, the holder does not even have to point to the <span class="math inline">\(c\)</span> public record: given <span class="math inline">\(s\)</span>, and assuming that approved commitments are recorded with a tag COMM indicating their nature, <span class="math inline">\(H\)</span> needs only prove the following claim:</p>
<p><span class="math display">\[\text{&quot;I know } r \text{ such that } Comm(r, s) \text{ appears in the public ledger with tag COMM&quot; }\]</span></p>
<p>This statement is obviously NP-complete. Consequently, it can be produced as a zk-SNARK proof upon the predicate</p>
<p><span class="math display">\[F(s, r) = Comm(r, s) \text{ appears in the public ledger with tag COMM }\]</span></p>
<p>The desired proof-of-knowledge mechanism can thus be a zk-SNARK cryptosystem with public predicate <span class="math inline">\(F\)</span>. The trapdoor <span class="math inline">\(r\)</span> serves as the secret witness to the serial number <span class="math inline">\(s\)</span>, which serves in turn as the public instance of the predicate.</p>
<p>Till now we have only adjusted part of the <em>ZeroCash</em> protocol to the <em>Diplomata</em> context, where awarded titles are interpreted as 1 BTC. We haven't though specified how approval of commitments should proceed. In ZeroCash, a holder's commitment to a particular bitcoin collection is approved and recorded by means of an escrow (e.g., when physical money is exchanged for electronic cash). In our protocol, this is equivalent to the certification on behalf of <span class="math inline">\(I\)</span> that <span class="math inline">\(c = Comm(r, s)\)</span> is a commitment to <span class="math inline">\(s\)</span>: in order to record <span class="math inline">\(c\)</span> in the public ledger, the issuer must first ensure that the holder has indeed committed to <span class="math inline">\(s\)</span> and not any arbitrary value. On the other hand, the trapdoor <span class="math inline">\(r\)</span> must remain eternally secret. In particular, <span class="math inline">\(H\)</span> cannot communicate <span class="math inline">\(r\)</span> to <span class="math inline">\(I\)</span> in order for the latter to unlock the commitment and certify its content: a dishonest <span class="math inline">\(I\)</span> could leak r to a malicious holder, who would then successfully prove possession of <span class="math inline">\(t\)</span> by simply generating a proof on top of the zk-SNARK infrastructure. We have to solve the following problem: how can the issuer certify commitment to the correct serial number without knowing the secret trapdoor?</p>
<p>To do so, we will take advantage of the commitment's internal mechanism. The scheme particularly suited for our purpose is the <em>Pedersen commitment scheme</em>, as will be explained in the following section.</p>
<h4 id="certification">Certification</h4>
<p>Let <span class="math inline">\(p\)</span> be a large prime, <span class="math inline">\(g\)</span> a generator of the group of quadratic residues in <span class="math inline">\(\mathbb{Z}_p^\star\)</span> and <span class="math inline">\(h\)</span> a randomly chosen residue. Fixing these public parameters, the <em>Pedersen commitment scheme</em> is defined as</p>
<p><span class="math display">\[Comm(r, s) = g^r h^s\]</span></p>
<p>(involved operations taken <span class="math inline">\(mod\)</span> <span class="math inline">\(p\)</span>). Security of the scheme (the hiding and binding properties) depends on further assumptions upon <span class="math inline">\(p\)</span> and <span class="math inline">\(g\)</span> to be stipulated when needed. We are here interested in the following key observation.</p>
<p><strong><em>Lemma 1</em></strong>. Fix <span class="math inline">\(p\)</span>, <span class="math inline">\(g\)</span>, <span class="math inline">\(h\)</span> such that <span class="math inline">\(Comm\)</span> be statistically secure. Let <span class="math inline">\(c = Comm(r, s)\)</span> be <span class="math inline">\(A\)</span>'s commitment to a secret <span class="math inline">\(s\)</span>, which is known to both <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>. If <span class="math inline">\(A\)</span> sends <span class="math inline">\(g^r\)</span> and <span class="math inline">\(c\)</span> to <span class="math inline">\(B\)</span>, then</p>
<ol style="list-style-type: decimal">
<li><span class="math inline">\(B\)</span> can check whether <span class="math inline">\(c\)</span> is a commitment to <span class="math inline">\(s\)</span> without knowing the trapdoor <span class="math inline">\(r\)</span></li>
<li><span class="math inline">\(B\)</span> cannot infer the value of <span class="math inline">\(r\)</span></li>
</ol>
<p>Indeed, knowing already <span class="math inline">\(s\)</span>, B can compute <span class="math inline">\(h^s\)</span> and check whether <span class="math inline">\(c\)</span> is equal to <span class="math inline">\(g^r h^s\)</span>. If <span class="math inline">\(A\)</span> had committed to any <span class="math inline">\(s^\prime \neq s\)</span>, i.e., <span class="math inline">\(c = g^r h^{s&#39;}\)</span>, then, in order to deceive <span class="math inline">\(B\)</span>, they would need to fabricate <span class="math inline">\(r^\prime\)</span> such that <span class="math inline">\(g^r h^{s&#39;} = g^{r&#39;} h^s\)</span> or, equivalently, solve</p>
<p><span class="math display">\[r^\prime = \log g^r h^{s^\prime-s}\]</span></p>
<p>which is computationally infeasible in view of discrete logarithm hardness. Based on the same hardness assumption, <span class="math inline">\(B\)</span> cannot infer <span class="math inline">\(r\)</span> from either <span class="math inline">\(g^r\)</span> or <span class="math inline">\(h^s\)</span> or their combinations.</p>
<p>The above observation applies to the <em>Diplomata</em> context by fixing the Pedersen schema as the system's commitment mechanism. Let a holder <span class="math inline">\(H\)</span> and an issuer <span class="math inline">\(I\)</span> have the roles of <span class="math inline">\(A\)</span> resp. <span class="math inline">\(B\)</span>, <span class="math inline">\(s\)</span> be the serial number of a title <span class="math inline">\(t\)</span> issued by <span class="math inline">\(I\)</span> to <span class="math inline">\(H\)</span> and <span class="math inline">\(c\)</span> the holder's commitment to that number. In order to repeatedly use <span class="math inline">\(c\)</span> as certificate in future proof-verify sessions, the holder requests from <span class="math inline">\(I\)</span> to approve their commitment and append it to the public ledger. More accurately, after committing with a randomly chosen trapdoor <span class="math inline">\(r\)</span>, <span class="math inline">\(H\)</span> sends <span class="math inline">\(s\)</span>, <span class="math inline">\(g^r\)</span> and <span class="math inline">\(c\)</span> to <span class="math inline">\(I\)</span> with the request to certify <span class="math inline">\(c\)</span> as commitment to <span class="math inline">\(s\)</span> and subsequently append it to the ledger. <span class="math inline">\(I\)</span> first looks in their database of awarded titles to see if <span class="math inline">\(s\)</span> corresponds indeed to any of them. If yes, <span class="math inline">\(I\)</span> proceeds to certification of <span class="math inline">\(c\)</span> by means of <span class="math inline">\(g^r\)</span>. In case of success, <span class="math inline">\(I\)</span> appends <span class="math inline">\(c\)</span> to the ledger; otherwise the holder's request is rejected. The trapdoor remains unrevealed to the issuer as should.</p>
<h3 id="formal-description">Formal description</h3>
<h4 id="setup">Setup</h4>
<p>Let <em>L</em> denote the public ledger. Among possibly others, we define a tag</p>
<p style="text-align: center;">
COMM,
</p>
<p>indicating a commitment to an awarded title's serial number, and specify that <em>only Issuers have the right to append records with this tag to the ledger</em>.</p>
<p>We fix a sufficiently high security parameter <span class="math inline">\(n\)</span> and randomly choose <span class="math inline">\(p = 2q + 1\)</span> to be a strong (i.e., such that <span class="math inline">\(q\)</span> is prime) <span class="math inline">\((n + 1)\)</span>-bit prime . Denoting by <span class="math inline">\(Q\subset\mathbb{Z}_p^\star\)</span> the group of quadratic residues, we randomly fix a generator <span class="math inline">\(g\)</span> of <span class="math inline">\(Q\)</span> and a residue <span class="math inline">\(h \in Q\)</span>. We denote by</p>
<p><span class="math display">\[\mathbb{Z}_p^\star\times\mathbb{Z}_p\ni(r, s) \mapsto Comm(r, s) = g^r h^s\]</span></p>
<p>the Pedersen function over the pair <span class="math inline">\((g, h)\)</span>. Under the above assumptions, discrete log hardness becomes plausible and <span class="math inline">\(Comm\)</span> may be considered as a statistically secure commitment mechanism. We specify that <em>serial numbers assigned by Issuers to titles be contained in</em> <span class="math inline">\(\mathbb{Z}_p\)</span>.</p>
<p>We next consider the predicate</p>
<p><span class="math display">\[F(s, r) = Comm(r, s) \text{ appears in } L \text{ with tag COMM }\]</span></p>
<p>Both lookup in <span class="math inline">\(L\)</span> and evaluation of <span class="math inline">\(Comm\)</span> are of polynomial time complexity. Consequently, for any <span class="math inline">\(s\)</span>, the statement</p>
<p><span class="math display">\[\text{I know } r \text{ such that } F(s, r) = 1\]</span></p>
<p>is NP-complete with respect to <span class="math inline">\(r\)</span>. This allows to use <span class="math inline">\(F\)</span> as the public predicate of a zk-SNARK cryptosystem, where the trapdoor is thought of as the private witness to the serial number. More accurately, feeding <span class="math inline">\(F\)</span> to a CRS-generator, we denote by</p>
<p style="text-align: center;">
CRS = <span class="math inline">\((pk, vk)\)</span>
</p>
<p>the pair of produced proving and verifying keys of the induced zk-SNARK cryptosystem. We will denote by</p>
<p><span class="math display">\[(\mathit{pk}, s, r) \mapsto \pi = \text{Prover}(\mathit{pk}, s, r),\]</span> <span class="math display">\[(vk, s, \pi) \mapsto \text{Verifier}(\mathit{vk}, s, \pi) \in \{0, 1\}\]</span></p>
<p>the Prover, resp. Verifier algorithms of the zk-SNARK cryptosystem. We specify that <em>every Holder can internally run a Prover and Verifiers coincide with Verifiers of the</em> zk-SNARK <em>cryptosystem</em>.</p>
<h4 id="cryptographic-flow">Cryptographic flow</h4>
<p>Let <span class="math inline">\(t\)</span> be a title issued by issuer <span class="math inline">\(I\)</span> to a holder <span class="math inline">\(H\)</span>. Upon issuance of <span class="math inline">\(t\)</span>, the preliminary Steps 1-3 take place.</p>
<ol style="list-style-type: decimal">
<li><p>Issuer <span class="math inline">\(I\)</span> uniquely assigns to <span class="math inline">\(t\)</span> a serial number <span class="math inline">\(s\in\mathbb{Z}_p\)</span>, which they store in their local database as the identifier of <span class="math inline">\(t\)</span>. (For transparency or history reasons, <span class="math inline">\(I\)</span> might record <span class="math inline">\(s\)</span> in the public ledger, but this is irrelevant to what follows.)</p></li>
<li><p>Issuer <span class="math inline">\(I\)</span> privately communicates <span class="math inline">\((s, t)\)</span> to holder <span class="math inline">\(H\)</span>.</p></li>
<li><p>Holder <span class="math inline">\(H\)</span> stores <span class="math inline">\(s\)</span> in their local database as the identifier of <span class="math inline">\(t\)</span>.</p></li>
</ol>
<p>In order for <span class="math inline">\(H\)</span> to be able to repeatedly prove possession of <span class="math inline">\(t\)</span>, they must enter at will the following certification phase (once per <span class="math inline">\(t\)</span>).</p>
<h5 id="certification-phase-once-per-title">Certification phase (once per title)</h5>
<ol start="4" style="list-style-type: decimal">
<li><p>Holder <span class="math inline">\(H\)</span> detects in their local database the serial number <span class="math inline">\(s\)</span> of <span class="math inline">\(t\)</span>.</p></li>
<li><p>Holder <span class="math inline">\(H\)</span> randomly chooses a trapdoor <span class="math inline">\(r\)</span> to compute <span class="math inline">\(g^r\)</span> and <span class="math inline">\(c = Comm(r, s) = g^r h^s\)</span>.</p></li>
<li><p>Holder <span class="math inline">\(H\)</span> stores <span class="math inline">\(r\)</span> in their local database as the private witness to <span class="math inline">\(s\)</span>.</p></li>
<li><p>Holder <span class="math inline">\(H\)</span> privately communicates <span class="math inline">\((g^r, c, s)\)</span> to <span class="math inline">\(I\)</span> with the request to approve <span class="math inline">\(c\)</span> and append it to <span class="math inline">\(L\)</span>.</p></li>
<li><p>Issuer <span class="math inline">\(I\)</span> looks through their local database to see if <span class="math inline">\(s\)</span> corresponds indeed to a title awarded to <span class="math inline">\(H\)</span>. If yes, issuer <span class="math inline">\(I\)</span> proceeds to Step 9; otherwise <span class="math inline">\(H\)</span>'s request is rejected and the certification phase terminates.</p></li>
<li><p>Issuer <span class="math inline">\(I\)</span> computes <span class="math inline">\(h^s\)</span> to check if <span class="math inline">\(c = g^r h^s\)</span>. If yes, <span class="math inline">\(I\)</span> proceeds to Step 10; otherwise <span class="math inline">\(H\)</span>'s request is rejected and the certification phase terminates.</p></li>
<li><p>Issuer <span class="math inline">\(I\)</span> appends <span class="math inline">\(c\)</span> to <span class="math inline">\(L\)</span> with tag COMM and informs <span class="math inline">\(H\)</span>.</p></li>
</ol>
<p>Note that a dishonest <span class="math inline">\(I\)</span> cannot avoid recording <span class="math inline">\(c\)</span> to the public ledger, since a honest <span class="math inline">\(H\)</span> can anytime audit <span class="math inline">\(L\)</span> to see if their commitment has been appended. Though not formally included in the protocol, it is a good practice that <span class="math inline">\(H\)</span> audits <span class="math inline">\(L\)</span> to check if <span class="math inline">\(c\)</span> has been appended indeed. On the other hand, nothing prevents a dishonest <span class="math inline">\(I\)</span> from appending an incorrect commitment to the ledger. We will see that this possibility does <em>not</em> affect the security of the protocol (cf. the <em>Proof of security in the standard model</em> section).</p>
<h5 id="proof-verify-session">Proof-verify session</h5>
<p>Let a verifier <span class="math inline">\(V\)</span> meet anonymously <span class="math inline">\(H\)</span> online. <span class="math inline">\(H\)</span> wishes to prove that they possess a title (in this case, <span class="math inline">\(t\)</span>) by only referring to its serial number <span class="math inline">\(s\)</span> (i.e., without revealing part of its content). Note that the relation between <span class="math inline">\(s\)</span> and <span class="math inline">\(t\)</span> is only known to <span class="math inline">\(I\)</span> and <span class="math inline">\(H\)</span>.</p>
<ol start="11" style="list-style-type: decimal">
<li><p>Holder <span class="math inline">\(H\)</span> detects in their local database the serial number <span class="math inline">\(s\)</span>, which identifies <span class="math inline">\(t\)</span> (cf. Step 3), and the private witness <span class="math inline">\(r\)</span> corresponding to <span class="math inline">\(s\)</span> (cf. Step 6).</p></li>
<li><p>Holder <span class="math inline">\(H\)</span> runs the zk-SNARK Prover over <span class="math inline">\((r, s)\)</span> to generate <span class="math inline">\(\pi = \text{Prover}(\mathit{pk}, s, r)\)</span></p></li>
</ol>
<p>The produced <span class="math inline">\(\pi\)</span> is namely a zk-SNARK proof that <span class="math inline">\(H\)</span> knows <span class="math inline">\(r\)</span> such that <span class="math inline">\(Comm(r, s)\)</span> has been publicly recorded by some certifying authority. Equivalently, <span class="math inline">\(\pi\)</span> proves possession of an awarded title on behalf of <span class="math inline">\(H\)</span>.</p>
<ol start="13" style="list-style-type: decimal">
<li><p>Holder <span class="math inline">\(H\)</span> privately communicates <span class="math inline">\((\pi, s)\)</span> to <span class="math inline">\(V\)</span>.</p></li>
<li><p>Verifier <span class="math inline">\(V\)</span> feeds <span class="math inline">\((\pi, s)\)</span> to the zk-SNARK Verifier: <span class="math inline">\(ans = \text{Verifier}(\mathit{vk}, s, \pi)\)</span>.</p></li>
<li><p>If <span class="math inline">\(ans = 1\)</span>, verifier <span class="math inline">\(V\)</span> accepts <span class="math inline">\(H\)</span>'s claim of knowledge; otherwise the claim is rejected.</p></li>
</ol>
<h3 id="proof-of-security-and-honesty-assumptions">Proof of security and honesty assumptions</h3>
<p>We first justify security of the protocol from the purely cryptographic viewpoint. No honesty assumptions are required with this respect. Some honesty assumptions upon holders and issuers are necessary to guarantee that secret parameters are not leaked by the entities knowing them: leakage of these parameters could potentially violate exclusiveness of rights upon an awarded title or compromise anonymity of the holder. Verifiers need not be honest.</p>
<p>In what follows, involved symbols refer to the above formal description.</p>
<h4 id="proof-of-security-in-the-standard-model">Proof of security in the standard model</h4>
<p>Standard references to stochastic tolerance are omitted and the discrete log assumption is taken for granted.</p>
<p><em>Completeness</em>: if <span class="math inline">\(c\)</span> is correct, i.e., <span class="math inline">\(c = g^r h^s\)</span>, then <span class="math inline">\(\pi\)</span> verifies.</p>
<p>Assuming completeness of the certification phase, this follows directly from completeness of the underling zk-SNARK cryptosystem. Consequently, we need only check that <span class="math inline">\(c\)</span> is appended to <span class="math inline">\(L\)</span>. But this follows directly from Step 9 and the auditability of the public ledger (cf. the comment at the end of the <em>Certification phase</em> section).</p>
<p><em>Soundness</em>: if <span class="math inline">\(c\)</span> is incorrect, i.e., <span class="math inline">\(c = g^r h^{s&#39;}\)</span> with <span class="math inline">\(s^\prime \neq s\)</span>, then <span class="math inline">\(\pi\)</span> does not verify.</p>
<p>Due to soundness of the zk-SNARK cryptosystem, we need only consider the case where <span class="math inline">\(c\)</span> has been approved by <span class="math inline">\(I\)</span> and appended to the ledger. Substituting <span class="math inline">\(H\)</span> and <span class="math inline">\(I\)</span> for <span class="math inline">\(A\)</span>, resp. <span class="math inline">\(B\)</span> in Lemma 1.1, a honest <span class="math inline">\(I\)</span> would be able to detect incorrectness of <span class="math inline">\(c\)</span> and thus abort the certification phase (Step 8). Consequently, <span class="math inline">\(I\)</span> is dishonest in that they certify the incorrect commitment <span class="math inline">\(c\)</span> on behalf of a dishonest holder <span class="math inline">\(H\)</span>. However, in spite of <span class="math inline">\(g^r h^{s&#39;}\)</span> appearing in the ledger, <span class="math inline">\(H\)</span> cannot prove possession of <span class="math inline">\(t\)</span>. In view of Steps 13-15, <span class="math inline">\(H\)</span> would still need to generate a verifiable zk-SNARK proof of the statement</p>
<p style="text-align: center;">
I know <span class="math inline">\(r^\prime\)</span> such that <span class="math inline">\(g^{r&#39;} h^s\)</span> appears in <span class="math inline">\(L\)</span> with tag COMM,
</p>
<p>where <span class="math inline">\(g^{r&#39;} h^s = g^r h^{s&#39;}\)</span>. More accurately, <span class="math inline">\(H\)</span> would need to compute</p>
<p><span class="math display">\[\text{Prover}(pk, s, r^\prime)\]</span></p>
<p>with <span class="math inline">\(r^\prime = \log g^r h^{s^\prime - s}\)</span>, contradicting the discrete log assumption.</p>
<h4 id="security-considerations">Security considerations</h4>
<p>Holder <span class="math inline">\(H\)</span> is normally the only entity with knowledge of <span class="math inline">\(r\)</span>. Suppose that <span class="math inline">\((r, s)\)</span> is somehow communicated to another holder <span class="math inline">\(H^\prime\)</span> to be a valid witness-instance pair. Then, by virtue of Steps 12-15 and the completely public character of the zk-SNARK cryptosystem, <span class="math inline">\(H^\prime\)</span> is able to prove for themselves possession of the title identified by <span class="math inline">\(s\)</span>. It thus makes sense to consider the following honesty assumption:</p>
<p style="text-align: center;">
AS1. For the sake of their exclusive rights upon <span class="math inline">\(t\)</span>, holder <span class="math inline">\(H\)</span> never communicates <span class="math inline">\(r\)</span> to anybody.
</p>
<p>Raising this assumption pertains to the following scenario: two dishonest holders <span class="math inline">\(H\)</span>, <span class="math inline">\(H^\prime\)</span> take advantage of anonymity and collaborate, so that the latter proves possession of a title awarded to the former.</p>
<p>There is still another way to violate exclusivity of rights upon <span class="math inline">\(t\)</span>, stemming from a dishonest <span class="math inline">\(I\)</span> in collaboration with a dishonest holder <span class="math inline">\(H^\prime\)</span>. Suppose that <span class="math inline">\(I\)</span> communicates <span class="math inline">\(s\)</span> to <span class="math inline">\(H^\prime\)</span>, who then enters a certification phase with <span class="math inline">\(I\)</span>: <span class="math inline">\(H\)</span> generates a correct commitment to <span class="math inline">\(s\)</span>, which <span class="math inline">\(I\)</span> maliciously (cf. Step 8) approves and appends to the ledger. It is then possible for <span class="math inline">\(H^\prime\)</span> to prove for themselves possession of the title awarded to <span class="math inline">\(H\)</span>. It thus makes sense to consider the following honesty assumption:</p>
<p style="text-align: center;">
AS2. For the sake of <span class="math inline">\(H\)</span>'s exclusive rights upon <span class="math inline">\(t\)</span>, issuer <span class="math inline">\(I\)</span> never approves anybody else's commitment to <span class="math inline">\(s\)</span>.
</p>
<h4 id="anonymity-considerations">Anonymity considerations</h4>
<p>Issuer <span class="math inline">\(I\)</span> and holder <span class="math inline">\(H\)</span> are normally the only entities with knowledge that <span class="math inline">\(s\)</span> is the serial number of <span class="math inline">\(t\)</span> (cf. Steps 1-3). Since <span class="math inline">\(t\)</span> contains most probably reference to <span class="math inline">\(H\)</span>'s identity, leakage of this relation could compromise the latter's anonymity. For example, if <span class="math inline">\(V\)</span> had for some reason accidental access to the content of <span class="math inline">\(t\)</span>, then, after completion of Step 13, <span class="math inline">\(V\)</span> would be able to infer <span class="math inline">\(H\)</span>'s identity. It thus makes sense to consider the following honesty assumption:</p>
<p style="text-align: center;">
AS3. For the sake of <span class="math inline">\(H\)</span>'s anonymity, neither <span class="math inline">\(I\)</span> nor <span class="math inline">\(H\)</span> ever communicates <span class="math inline">\((s, t)\)</span> to anybody.
</p>
<h3 id="performance-optimization">Performance optimization</h3>
<h4 id="optimizing-commitment-detection-for-scaling">Optimizing commitment detection for scaling</h4>
<p>Detection of a particular record with tag COMM in the ledger is crucial for the protocol and an operation to be massively repeated (once for each proof-verify session), since it is involved in the evaluation of the zk-SNARK public predicate. More accurately, ledger lookup is incorporated in the CRS, which yields the fixed ingredient <span class="math inline">\(vk\)</span> in the verification of any zk-SNARK proof. A naive implementation of commitment detection can thus severely limit scalability, since the verification algorithm most probably grows linearly with the length of the public ledger.</p>
<p>We can remedy this by organizing certified commitments to an additional linear structure, representing the leaves of a Merkle-tree <span class="math inline">\(T\)</span>: each time a commitment is certified, <span class="math inline">\(T\)</span> is updated with the hash of this commitment. In other words, tree <span class="math inline">\(T\)</span> records a specialized history of certified commitments, so that one can directly audit <span class="math inline">\(T\)</span> instead of <span class="math inline">\(L\)</span> to see if a commitment has been approved by an issuer. It is well known that update and leaf lookup for a Merkle-tree are of logarithmic time and space complexity with respect to the number of leaves. Consequently, auditing <span class="math inline">\(T\)</span> instead of <span class="math inline">\(L\)</span> reduces the complexity of <span class="math inline">\(F\)</span>'s evaluation from linear to logarithmic with respect to the number of records.</p>
<p>In integrating the Merkle-tree machinery with our protocol, we proceed as follows. Upon setup, we initialize an empty Merkle-tree <span class="math inline">\(T\)</span> with hash function <span class="math inline">\(\tilde{h}\)</span> and assume that a <span class="math inline">\(\text{verify_merkle_proof}()\)</span> function is available for verifying Merkle-proofs. Let <span class="math inline">\(T.\text{audit_proof}()\)</span> denote <span class="math inline">\(T\)</span>'s functionality for generating audit proofs upon given records. In particular, a record <span class="math inline">\(a\)</span> has been hashed and stored among <span class="math inline">\(T\)</span>'s leaves if and only if</p>
<p><span class="math display">\[\text{verify_merkle_proof}(T.\text{audit_proof}(\tilde{h}(a))) = 1\]</span></p>
<p>With this notation, the zk-SNARK public predicate reformulates as</p>
<p><span class="math display">\[F(s, r) = \text{verify_merkle_proof}(T.\text{audit_proof}(\tilde{h}(Comm(r, s))))\]</span></p>
<p>In order for this to work, all we have to do is modify Step 10 of the certification phase as follows:</p>
<p style="text-align: center;">
Issuer <span class="math inline">\(I\)</span> updates <span class="math inline">\(T\)</span> with <span class="math inline">\(c\)</span> and informs <span class="math inline">\(H\)</span>
</p>
<p>Holder <span class="math inline">\(H\)</span> can then directly audit <span class="math inline">\(T\)</span> to check if their commitment has indeed been certified. Note that, in this modified protocol, usage of the COMM tag becomes inessential with respect to our specific purposes. However, issuer <span class="math inline">\(I\)</span> may still record certified commitments in <span class="math inline">\(L\)</span> with tag COMM for history and transparency reasons.</p>
<h4 id="accelerating-verification">Accelerating verification</h4>
<p>This is a generic zk-SNARK technique exclusively affecting the Setup and Verifier algorithms of the underlying zk-SNARK cryptosystem. See <em>Accelerating verification with a preprocessed key</em> in Appendix B.</p>
<h2 id="application-architecture">Application architecture</h2>
<h2 id="appendix">Appendix</h2>
<h3 id="a-generic-commitment-scheme">A Generic commitment scheme</h3>
<p>A (<em>statistically</em>) <em>secure commitment scheme</em> consists of a pair of functions</p>
<p><span class="math display">\[r, m \mapsto c = Comm(r, m)\text{,}\]</span></p>
<p><span class="math inline">\(m\)</span> coming from a set of acceptable messages <span class="math inline">\(M\)</span> and <span class="math inline">\(c\)</span> referred to as <em>commitment</em> to <span class="math inline">\(m\)</span> with <em>trapdoor</em> <span class="math inline">\(r\)</span>, and</p>
<p><span class="math display">\[r, c \mapsto m = Open(r, c)\]</span></p>
<p>referred to as the <em>opening function</em>, such that</p>
<ol style="list-style-type: decimal">
<li>(<em>Correctness</em>) opening the commitment with the correct trapdoor yields the original message, i.e.</li>
</ol>
<p><span class="math display">\[Open(r, Comm(r, m)) = m\]</span></p>
<ol start="2" style="list-style-type: decimal">
<li><p>(<em>Hiding</em>) it is computationally infeasible to infer the original message from the commitment alone, i.e., given <span class="math inline">\(c = Comm(r, m)\)</span>, it is (with overwhelming probability) impossible to find <span class="math inline">\(r&#39;\)</span> such that <span class="math inline">\(m = Open(r^{\prime}, c)\)</span></p></li>
<li><p>(<em>Binding</em>) it is computationally infeasible to anyhow extract from the commitment a message other than the original, i.e., given <span class="math inline">\(c = Comm(r, m)\)</span>, it is (with overwhelming probability) impossible to find <span class="math inline">\(r^{\prime}\)</span> such that <span class="math inline">\(m^{\prime} = Open(r^{\prime}, c) \in M\)</span> and <span class="math inline">\(m^{\prime} \neq m\)</span>.</p></li>
</ol>
<p>Let <span class="math inline">\(A\)</span> commit to a message <span class="math inline">\(m\)</span> with trapdoor <span class="math inline">\(r\)</span> and send the commitment <span class="math inline">\(c\)</span> to <span class="math inline">\(B\)</span>. In view of correctness, the <em>hiding</em> property means that <span class="math inline">\(c\)</span> resembles a box containing <span class="math inline">\(m\)</span> in the hands of <span class="math inline">\(B\)</span>, whose key <span class="math inline">\(r\)</span> is controlled by <span class="math inline">\(A\)</span>: <span class="math inline">\(B\)</span> will never learn <span class="math inline">\(m\)</span> unless <span class="math inline">\(A\)</span> chooses to reveal <span class="math inline">\(r\)</span> to them. On the counterpoint, again in view of correctness, the <em>binding</em> property means that the box can be unlocked by <span class="math inline">\(A\)</span> in only one meaningful way: <span class="math inline">\(A\)</span> cannot fabricate a trapdoor so that opening the box with it leads to any acceptable content other than the original.</p>
<h3 id="b-generic-zk-snark-scheme">B Generic zk-SNARK scheme</h3>
<p>A zk-SNARK (Zero-Knowledge Succinct Non-interactive ARgument of Knowledge) is a general purpose cryptographic scheme for generating and verifying zero-knowledge proofs in efficient and non-interactive fashion. Statements to be proven are claims of knowledge of a quantity <em>w</em> (called <em>withness</em>) satisfying <em>F(x, w)</em>, where <em>x</em> is a public quantity (called <em>instance</em>) and <em>F</em> is a public relation (called <em>predicate</em>). More accurately, without revealing info about <em>w</em>, the prover wishes to generate a proof of the following statement:</p>
<p><span class="math display">\[
\text{given } x \in X \text{ and } F: X \times W \mapsto \{0,
        1\}, \text{ I know a } w \text{ such that } F(x, w) = 1
\]</span></p>
<p>where <span class="math inline">\(X\)</span> is the set of acceptable public instances, <span class="math inline">\(W\)</span> is the set of acceptable private witnesses and 0, 1 hold their usual logical meanings. For example, if the verifier were a web server holding a database of hashed passwords and the prover were the web client of a registered user, the latter does not need to send their password <em>w</em> (as cleartext or in disguise) in order to login, but only a proof of the above statement with predicate:</p>
<p><span class="math display">\[ F(x, w) := \{H(w) = x\}\]</span></p>
<p>where <span class="math inline">\(H\)</span> is the hash function used by the server, <em>W</em> being the preimage set and <span class="math inline">\(X\)</span> the set of stored hashed passwords in the database. To give a more relevant example from the cryptocurrency framework, if <span class="math inline">\(w\)</span> were the encoding of the private payment details of a particular transaction and <span class="math inline">\(x\)</span> the encrypted version of this data, then the predicate <span class="math inline">\(F\)</span> would typically be</p>
<p><span class="math display">\[ F(x, w) = \{w \text{ is a well-formed transaction and } x
        \text{ is the encryption of it}\} \]</span></p>
<p>Note that <span class="math inline">\(F\)</span> is predefined and fixed, which allows for <em>non-interactive</em> mode (see below). Generation and verification of proofs for various witness-instance pairs <span class="math inline">\((w, x)\)</span> is instead a massively repeated procedure. Efficiency of the cryptosystem refers thus not to its initial setup (which only involves <span class="math inline">\(F\)</span>) but to the generation and verification of proofs (involving arbitrary instantiations of <span class="math inline">\((w, x)\)</span> pairs), which naturally leads to the notion of <em>succinctness</em> (see below).</p>
<h4 id="predicate-reduction">Predicate reduction</h4>
<p>In theory, any NP-complete statement which is expressible in the above form may serve as the fixed public predicate of a zk-SNARK cryptosystem. However, transforming the predicate so that it be amenable to low-level cryptographic operations is a genuine challenge. That is, except if following recipes, configuration of the cryptosystem may well be a non-trivial step from the implementors' viewpoint.</p>
<p>After completion of the initial setup, the predicate <span class="math inline">\(F\)</span> may be thought of as a fixed circuit of logical gates. In a blockchain context, this means to encode in the form of a circuit the consensus rules of the network. Satisfaction of <span class="math inline">\(F\)</span> for a witness-instance pair <span class="math inline">\((w, x)\)</span> emulates a particular state of the circuit after running it with that input. zk-SNARK libraries usually avail a mechanism for modelling predicates as logical circuits which resembles the concept of <em>protoboard</em> (prototyping board) from electrical engineering: the cryptosystem's configuration presupposes allocation of <span class="math inline">\(F\)</span>'s &quot;chips&quot; to the protoboard.</p>
<p>This is however only a convenient abstraction. What in fact one must do is appropriately reduce the NP-statement <span class="math inline">\(F\)</span> to a quadratic system of polynomial equations. Satisfiability of <span class="math inline">\(F\)</span> for a given pair <span class="math inline">\((w, x)\)</span> amounts to <span class="math inline">\((x, w)\)</span> being (with overwhelming probability) a solution to this system of equations. More specifically, it has been proven that any NP-complete statement can be reduced to such system of a special kind, usually referred to as a <em>set of quadratic constraints</em>, with each zk-SNARK proof attesting that this set of constraints is satisfied by some concrete input. Further results show that any set of quadratic constraints can be conveniently flattened to what is known as <em>R1CS</em> (<em>Rank 1 Constraint System</em>). Predicate reduction amounts thus to reformulating an NP-complete statement as R1CS.</p>
<h4 id="cryptographic-flow-1">Cryptographic flow</h4>
<p>We expose here the ZS-NARK cryptographic flow for reference, in order to gradually attain semi-formal language and terminology. The flow involves three basic algorithms run by homonymous and mutually independent components: <em>Setup</em>, <em>Prover</em> and <em>Verifier</em>. How these components are distributed among network entities depends on the protocol under implementation.</p>
<p>The Setup algorithm is typically run once by a unanimously trusted party. It is fed with a R1CS (i.e., the fixed public predicate <em>F</em>) and outputs the public CRS (<em>Common Reference String</em>) involved in any subsequent proof generation and verification. In particular, the CRS consists of a proving key <em>pk</em> (uniformly used by all Provers) and a uniquely correlated verification key <em>vk</em> (uniformly used by all Verifiers). Computation of CRS involves also a once used randomness <span class="math inline">\(\mathit{lambda}\)</span>, so that it can formally be expressed as follows:</p>
<p><span class="math display">\[ (F, \mathit{lambda}) \mapsto \text{CRS} := (pk, vk) =
   \mathrm{Setup}(F, \mathit{lambda})\]</span></p>
<p>It is essential that <span class="math inline">\(\mathit{lambda}\)</span> remains eternally secret: leakage of randomness would allow a malicious prover to generate false proofs that can erroneously be verified. Trustedness of the Setup party must thus be equivalent to the unanimously accepted guarantee, that the <span class="math inline">\(\mathit{lambda}\)</span> parameter has irreversibly been eliminated after CRS generation (which is the reason for the destruction ceremonies surrounding ZCash etc.).</p>
<p>Upon every proof generation, the Prover is fed with a public instance <span class="math inline">\(x\)</span> and a secret witness <span class="math inline">\(w\)</span> for it. Using the proving part <span class="math inline">\(\mathit{pk}\)</span> of the CRS, the prover generates a proof <span class="math inline">\(\pi\)</span> attesting that <span class="math inline">\(F(x, \cdot)\)</span> is satisfiable by some known <span class="math inline">\(w\)</span>, without disclosing any info about <span class="math inline">\(w\)</span> (i.e., except for the claim that it is known). This can formally be expressed as</p>
<p><span class="math display">\[ (\mathit{pk}, x, w) \mapsto \pi = \text{Prover}(\mathit{pk}, x, w) \]</span></p>
<p>The Verifier uses the verifying part <span class="math inline">\(\mathit{vk}\)</span> of the CRS to operate upon the provided proof, accepting or rejecting according to whether it was found to be valid, resp. invalid:</p>
<p><span class="math display">\[ (vk, x, \pi) \mapsto \text{Verifier}(vk, x, \pi) \in \{0, 1\} \]</span></p>
<p>Note that typically anyone can run a Verifier.</p>
<p>In this context, the zk-SNARK properties are formalized as follows:</p>
<ul>
<li><p><em>zk</em> (<em>Zero Knowledge</em>): The generated proof conveys no info about <span class="math inline">\(w\)</span> beyond the claim of it being known, i.e., that <span class="math inline">\(F(x, .)\)</span> is satisfied by it.</p></li>
<li><p><em>S</em> (<em>Succinct</em>): The size of proofs is small, constant and independent of the system's constraints and public inputs. More accurately, omitting dependence on security parameters, proof generation is <span class="math inline">\(O(1)\)</span> and verification is <span class="math inline">\(O(k)\)</span>, where <span class="math inline">\(k\)</span> stands for the proof uniform bitsize. The bottleneck of initial setup needs not be taken into account.</p></li>
<li><p><em>N</em> (<em>Non-interactive</em>): The only interaction between Prover and Verifier is the transmission of the produced proof (one communication step). Any intermediate computation required for proof generation and verification has been absorbed in the precomputation of the CRS (involved via usage of <span class="math inline">\(\mathit{pk}\)</span> and <span class="math inline">\(\mathit{vk}\)</span>).</p></li>
</ul>
<p>Generic requirements may also be formalized as follows:</p>
<ul>
<li><em>Completeness</em>: Correct proofs, that is, generated upon a correct witness, always (i.e., with overwhelming probability) verify. More accurately, omitting reference to stochastic tolerance,</li>
</ul>
<p><span class="math display">\[
\begin{align*}
&amp;\textrm{for any } \pi =
\mathrm{Prover}(pk, x, w) \textrm{ such that } F(x, w) = 1,\\
&amp;\textrm{there holds } \mathrm{Verifier}(vk, x, \pi) = 1
\end{align*}
\]</span></p>
<ul>
<li><em>Soundness</em>: No false proof, that is, generated upon an incorrect witness, ever (i.e., with overwhelming probability) verifies. More accurately, omitting reference to stochastic tolerance,</li>
</ul>
<p><span class="math display">\[
\begin{align*}
&amp;\textrm{for any } x \textrm{ such that } F(x, .)
\textrm{ not satisfiable, there exists no } w \text{ such that } \\
&amp;\mathrm{Verifier}(vk, x, \pi) = 1 \text{ with } \pi =
\mathrm{Prover}(pk, x, w)
\end{align*}
\]</span></p>
<h4 id="accelerating-verification-with-a-preprocessed-key">Accelerating verification with a preprocessed key</h4>
<p>For the purpose of faster verification, the verifying key <span class="math inline">\(vk\)</span> may be further processed during initial setup of the zk-SNARK cryptosystem, yielding a so called <em>preprocessed</em> verification key <span class="math inline">\(pvk\)</span>. In particular, a small amount of extra precomputed info can be added to it, in which case the Verifier algorithm must also be modified appropriately (&quot;online&quot; Verifier).</p>
<p>Note that proof generation is not affected by the usage of preprocessed verification keys.</p>
</body>
</html>
